%%%%%%%%%%%% Packages

\usepackage{pgfplots}
\pgfplotsset{compat=newest}

%%%%%%%%%%%% Libraries

\usetikzlibrary{math}
\usetikzlibrary{calc}
\usetikzlibrary{shapes}
\usetikzlibrary{arrows}
\usetikzlibrary{tikzmark}
\usetikzlibrary{positioning}
\usetikzlibrary{scopes}
\usetikzlibrary{shapes.multipart}
\usetikzlibrary{shapes.geometric}
\usetikzlibrary{bending}
\usetikzlibrary{decorations.markings}
\usetikzlibrary{intersections}

% curve through points: (A) to[curve through={(B) .. (C) .. (...)}] {Z};
% \usetikzlibrary{hobby}

%%%%%%%%%%%% Common settings

\newcommand{\tiklzcommonsettings}{
  \tikzset{
    every node/.append style={
      inner sep=0,
      outer sep=0
    },
    axis/.append style={
      black,
      ->
    },
    label text/.append style={
      outer sep=1
    }
  }
}

% Floating point calculations
\ExplSyntaxOn
\cs_set_eq:NN \fpeval \fp_eval:n
\ExplSyntaxOff

%%%%%%%%%%%% 3D coordinate system settings

\makeatletter
\define@key{coordKeys}{altitude}{\def\altitude{#1}}
\define@key{coordKeys}{azimuth}{\def\azimuth{#1}}
\makeatother
\newcommand{\tiklzSetViewAngle}[1][]{
  \setkeys{coordKeys}{altitude=20,#1}%
  \setkeys{coordKeys}{azimuth=40,#1}%
  \tikzmath{
    \tikzAltitude=90-\altitude;
    \tikzAzimuth=90+\azimuth;
  }
  \tdplotsetmaincoords{\tikzAltitude}{\tikzAzimuth}
  \tikzmath{
    \X = cos(\altitude)*cos(\azimuth);
    \Y = cos(\altitude)*sin(\azimuth);
    \Z = sin(\altitude);
  }
  \xdef\viewVector{\X,\Y,\Z}
}

%%%%%%%%%%%% Ellipsoid

\makeatletter
\define@key{ellipseKeys}{x}{\def\x{#1}}
\define@key{ellipseKeys}{y}{\def\y{#1}}
\define@key{ellipseKeys}{maj}{\def\maj{#1}}
\define@key{ellipseKeys}{min}{\def\min{#1}}
\define@key{ellipseKeys}{rot}{\def\rot{#1}}
\define@key{ellipseKeys}{style}{\def\style{#1}}
\define@key{ellipseKeys}{name}{\def\name{#1}}
\makeatother
\newcommand{\ellipse}[1][]{
  \setkeys{ellipseKeys}{x=0,#1}%
  \setkeys{ellipseKeys}{y=0,#1}%
  \setkeys{ellipseKeys}{min=1,#1}%
  \setkeys{ellipseKeys}{maj=2,#1}%
  \setkeys{ellipseKeys}{rot=0,#1}%
  \setkeys{ellipseKeys}{style={},#1}%
  \setkeys{ellipseKeys}{name=ellipse,#1}%
  \node[
  \style,
  inner sep=0,
  outer sep=0,
  ellipse,
  minimum width=\min*1cm,
  minimum height=\maj*1cm,
  rotate=\rot] (\name) at (\x,\y) {};
}

%%%%%%%%%%%% Quadrotor

\newcommand{\sphereCoord}[2]{
  % return x,y,z a point on a sphere
  % #1: sphere radius
  % #2: azimuth angle, altitude angle
  \tikzmath{
    \X = #1*cos({#2}[1])*cos({#2}[0]);
    \Y = #1*cos({#2}[1])*sin({#2}[0]);
    \Z = #1*sin({#2}[1]);
  }
}

\newcommand{\convertTaitBryanToTikZ}[3]{
  % set (\TikZalpha,\TikZbeta,\TikZgamma) the coordinates to
  % tdplotsetrotatedcoords
  \pgfmathsetmacro\yaw{#1}
  \pgfmathsetmacro\pitch{#2}
  \pgfmathsetmacro\roll{#3}
  \tikzmath{
    \degToRad = \fpeval{pi/180};
    \radToDeg = \fpeval{180/pi};
    \TBpsi = \yaw*\degToRad;
    \TBtheta = \pitch*\degToRad;
    \TBphi = \roll*\degToRad;
    % 
    \TikZbeta = \fpeval{acos(cos(\TBtheta)*cos(\TBphi))};
    \TikZalpha = 0;
    \TikZgamma = 0;
  }
  \pgfmathparse{abs(\TikZbeta)<1e-4 ? 1:0}
  \ifthenelse{\pgfmathresult>0}{
    % Gimbal lock
    \tikzmath{
      \TikZgamma = 0;
      \TikZalpha = \fpeval{\TBpsi};
    }
  }{
    % Normal operation
    \tikzmath{
      \TikZgamma =
      atan2(\fpeval{cos(\TBtheta)*sin(\TBphi)},\fpeval{sin(\TBtheta)})*
      \degToRad;
      \TikZalpha = atan2(
      \fpeval{cos(\TBphi)*sin(\TBpsi)*sin(\TBtheta)-cos(\TBpsi)*sin(\TBphi)},
      \fpeval{sin(\TBpsi)*sin(\TBphi)+cos(\TBpsi)*cos(\TBphi)*sin(\TBtheta)})*\degToRad;
    }
  }
  \tikzmath{
    \TikZalpha = \TikZalpha*\radToDeg;
    \TikZbeta = \TikZbeta*\radToDeg;
    \TikZgamma = \TikZgamma*\radToDeg;
  }
  \xdef\TikZalpha{\TikZalpha}
  \xdef\TikZbeta{\TikZbeta}
  \xdef\TikZgamma{\TikZgamma}
}

\makeatletter
\define@key{droneKeysNew}{yaw}{\def\yaw{#1}}
\define@key{droneKeysNew}{pitch}{\def\pitch{#1}}
\define@key{droneKeysNew}{roll}{\def\roll{#1}}
\define@key{droneKeysNew}{x}{\def\x{#1}}
\define@key{droneKeysNew}{y}{\def\y{#1}}
\define@key{droneKeysNew}{scale}{\def\scale{#1}}
\define@key{droneKeysNew}{layers}{\def\layers{#1}}
\define@key{droneKeysNew}{showaxes}{\def\showaxes{#1}}
\makeatother
\xdef\QuadCounter{1}
\newcommand{\quadrotor}[1][]{
  \setkeys{droneKeysNew}{yaw=0,#1}%
  \setkeys{droneKeysNew}{pitch=0,#1}%
  \setkeys{droneKeysNew}{roll=0,#1}%
  \setkeys{droneKeysNew}{x=0,#1}%
  \setkeys{droneKeysNew}{y=0,#1}%
  \setkeys{droneKeysNew}{scale=1,#1}%
  \setkeys{droneKeysNew}{showaxes=false,#1}%
  \setkeys{droneKeysNew}{layers={AFR,ARR,ARL,BH,AFL,RFR,RFL,RRR,RRL},#1}%
  % Parameters
  \tikzmath{
    \Larm = 1;
    \Rr = 0.9;
    \armNorm = sqrt(2)*\Larm;
    \rx1 = \Larm;
    \ry1 = \Larm;
    \rx2 = \Larm;
    \ry2 = -\Larm;
    \rx3 = -\Larm;
    \ry3 = -\Larm;
    \rx4 = -\Larm;
    \ry4 = \Larm;
    \armwidth=0.40mm*\scale;
    \rotorlinewidth=0.40mm*\scale;
    \hubsize=\scale*0.15mm;
  }
  \def\frontRotorInnerColor{orange!100}
  \def\frontRotorOuterColor{orange!40}
  \def\frontRearInnerColor{black!40}
  \def\frontRearOuterColor{black!5}
  \tikzset{
    rotor/.append style={
      shading=radial,
      line width=\rotorlinewidth,
      fill opacity=0.8
    }
  }
  \convertTaitBryanToTikZ{\yaw}{\pitch}{\roll}
  % Plot quad
  \tdplotsetrotatedcoords{\TikZalpha}{\TikZbeta}{\TikZgamma}
  \begin{scope}[
    shift={(\x,\y)},
    tdplot_rotated_coords,
    scale=\scale]
    % Axes
    \ifthenelse{\equal{\showaxes}{}}{
      \draw[->,red] (0,0,0) -- (1,0,0);
      \draw[->,green] (0,0,0) -- (0,1,0);
      \draw[->,blue] (0,0,0) -- (0,0,1);
    }{}
    % Arms
    \expandafter\newsavebox\csname AFR\QuadCounter\endcsname
    \expandafter\newsavebox\csname AFL\QuadCounter\endcsname
    \expandafter\newsavebox\csname ARR\QuadCounter\endcsname
    \expandafter\newsavebox\csname ARL\QuadCounter\endcsname
    \foreach \i/\name in {1/FL,2/FR,3/RR,4/RL} {
      \begin{lrbox}{\csname A\name\QuadCounter\endcsname}
        \tikzmath{
          \armX = \rx\i/(\armNorm)*\hubsize/2;
          \armY = \ry\i/(\armNorm)*\hubsize/2;
        }
        \draw[line width=\armwidth]
        (\armX,\armY,0) to (\rx\i,\ry\i,0);
      \end{lrbox}
      \global%
      \expandafter\setbox\csname A\name\QuadCounter\endcsname%
      \expandafter\box\csname A\name\QuadCounter\endcsname%
    }
    % Electronics hub
    \expandafter\newsavebox\csname BH\QuadCounter\endcsname
    \begin{lrbox}{\csname BH\QuadCounter\endcsname}
      \node[
      circle,
      shading=radial,
      outer color=black!100,
      inner color=black!10,
      minimum size=\hubsize*1cm,
      inner sep=0
      ] at (0,0,0) {};
    \end{lrbox}
    % Rotors
    \expandafter\newsavebox\csname RFR\QuadCounter\endcsname
    \expandafter\newsavebox\csname RFL\QuadCounter\endcsname
    \expandafter\newsavebox\csname RRR\QuadCounter\endcsname
    \expandafter\newsavebox\csname RRL\QuadCounter\endcsname
    % Rotor 1
    \begin{lrbox}{\csname RFR\QuadCounter\endcsname}
      \begin{scope}[shift={(\rx1,\ry1)}]
        \draw[
        rotor,
        outer color=\frontRotorOuterColor,
        inner color=\frontRotorInnerColor]
        (0,0) circle (\Rr);
      \end{scope}
    \end{lrbox}
    % Rotor 2
    \begin{lrbox}{\csname RRR\QuadCounter\endcsname}
      \begin{scope}[shift={(\rx2,\ry2)}]
        \draw[
        rotor,
        outer color=\frontRotorOuterColor,
        inner color=\frontRotorInnerColor]
        (0,0) circle (\Rr);
      \end{scope}
    \end{lrbox}            
    % Rotor 3
    \begin{lrbox}{\csname RRL\QuadCounter\endcsname}
      \begin{scope}[shift={(\rx3,\ry3)}]
        \draw[
        rotor,
        outer color=\frontRearOuterColor,
        inner color=\frontRearInnerColor]
        (0,0) circle (\Rr);
      \end{scope}
    \end{lrbox}                        
    % Rotor 4
    \begin{lrbox}{\csname RFL\QuadCounter\endcsname}
      \begin{scope}[shift={(\rx4,\ry4)}]
        \draw[
        rotor,
        outer color=\frontRearOuterColor,
        inner color=\frontRearInnerColor]
        (0,0) circle (\Rr);
      \end{scope}
    \end{lrbox}
    % Now draw everything
    \foreach \obj in \layers {
      \expandafter\usebox\csname \obj\QuadCounter\endcsname
    }
  \end{scope}
  \tikzmath{\QuadCounter=int(\QuadCounter+1);}
  \xdef\QuadCounter{\QuadCounter}
}

%%%%%%%%%%%% Vector difference

\newcommand{\vectorDiff}[2]{
  % return the difference a - b
  % #1: vector a
  % #2: vector b
  \tikzmath{
    \X = {#1}[0]-{#2}[0];
    \Y = {#1}[1]-{#2}[1];
    \Z = {#1}[2]-{#2}[2];
  }
}

%%%%%%%%%%%% Vector dot product

\newcommand{\dotProduct}[2]{
  % return the dot product a . b
  % #1: vector a
  % #2: vector b
  \tikzmath
  {
    \OUT = {#1}[0]*{#2}[0]+{#1}[1]*{#2}[1]+{#1}[2]*{#2}[2];
  }
}

%%%%%%%%%%%% Vector cross product

\newcommand{\crossProduct}[2]{
  % return the cross product a x b
  % #1: vector a
  % #2: vector b
  \tikzmath
  {
    \X = {#1}[1]*{#2}[2]-{#1}[2]*{#2}[1];
    \Y = {#1}[2]*{#2}[0]-{#1}[0]*{#2}[2];
    \Z = {#1}[0]*{#2}[1]-{#1}[1]*{#2}[0];
  }
}

%%%%%%%%%%%% Rocket lander

\makeatletter
\define@key{rocketKeys}{shift}{\def\shift{#1}}
\define@key{rocketKeys}{legs}{\def\legs{#1}}
\define@key{rocketKeys}{fire}{\def\fire{#1}}
\makeatother
\newcommand{\rocket}[1][]{
  \setkeys{rocketKeys}{shift={(0,0)},#1}%
  \setkeys{rocketKeys}{legs=out,#1}%
  \setkeys{rocketKeys}{fire=false,#1}%
  \begin{scope}[shift={\shift}]
    \ifthenelse{\equal{\legs}{out}}{
      \tikzmath{\lAng = 60;}
    }{
      \tikzmath{\lAng = 180;}
    }
    \tikzmath{
      % User
      \rL = 2;
      \rW = 0.3;
      \lL = 0.6;
      \lW = 0.1;
      \lCF = 0.2;
      \lCH = 0.15;
      \eW = 0.3*\rW;
      \eH = 0.07;
      \eAng = 30;
      \eBellOutAng = -30;
      \eBellInAng = 90;
      \fH = 0.4;
      % Derived
      \lX = \lL*sin(\lAng);
      \lH = \lL*cos(\lAng);
      \eX = \eH*tan(\eAng);
    }
    \tikzset{
      every node/.append style={
        inner sep=0,
        outer sep=0
      },
      fuselage/.append style={
        rectangle,
        draw=black,
        minimum width=\rW cm,
        minimum height=\rL cm,
        shading=axis,
        shading angle=0,
        left color=white,
        right color=gray
      },
      leg/.append style={
        fill=black,
        draw=black,
        line join=bevel
      },
      leg cylinder/.append style={
        black,
        line width=0.2mm
      },
      engine bell/.append style={
        draw=black,
        shading=axis,
        shading angle=0,
        left color=gray,
        right color=black
      },
      engine fire/.append style={
        shading=axis,
        top color=orange,
        bottom color=yellow,
        draw=none
      }
    }
    \node[fuselage] (body) at (0,0) {};

    \draw[leg] (body.south west) to ++(-\lX,-\lH) to
    node[pos=\lCF](cylinder left){} ++(\lX,\lH+\lW) -- cycle;
    \draw[leg] (body.south east) to ++(\lX,-\lH) to
    node[pos=\lCF](cylinder right){} ++(-\lX,\lH+\lW) -- cycle;

    \draw[leg cylinder] ($(body.south west)+(0,\lW+\lCH)$)
    to (cylinder left);
    \draw[leg cylinder] ($(body.south east)+(0,\lW+\lCH)$)
    to (cylinder right);

    \coordinate (engine south east) at ($(body.south)+(\eW/2+\eX,-\eH)$);
    \coordinate (engine south west) at ($(body.south)+(-\eW/2-\eX,-\eH)$);
    
    \ifthenelse{\equal{\fire}{true}}{
      \draw[engine fire] (engine south east) to ++(-\eW/2-\eX,-\fH) to
      (engine south west) --cycle;
    }{}

    \draw[engine bell] (body.south) to ++(\eW/2,0)
    to[out=\eBellOutAng,in=\eBellInAng] ++(\eX,-\eH)
    to ++(-\eW-2*\eX,0)
    to[out=\eBellInAng,in=-180-\eBellOutAng] ++(\eX,\eH)
    --cycle;
  \end{scope}
}

%%%%%%%%%%%% Center of gravity

\makeatletter
\define@key{cgKeys}{shift}{\def\shift{#1}}
\makeatother
\newcommand{\cg}[1][]{
  \setkeys{cgKeys}{shift={(0,0)},#1}%
  \begin{scope}[shift={\shift}]
    % CG
    \tikzmath{
      \cgR = 0.15;
    }
    \tikzset{
      cg bg/.append style={
        circle,
        fill=white,
        draw=black,
        minimum size=\cgR cm
      },
      cg fg/.append style={
        circle,
        fill=black,
        draw=black
      }
    }
    \node[cg bg] at (0,0) {};
    \draw[cg fg] ($(0,0)+(0:\cgR cm/2)$) arc (0:90:\cgR cm/2) to (0,0) --
    cycle;
    \draw[cg fg] ($(0,0)+(180:\cgR cm/2)$) arc (180:270:\cgR cm/2) to (0,0) -- cycle;
  \end{scope}
}

%%%%%%%%%%%% Cute clock

\newcommand{\cuteclock}[1][]{
  \begin{scope}[#1]
    \tikzset{
      skinny/.append style={
        inner sep=0,
        outer sep=0
      },
      clockHand/.append style={
        line width=0.2mm
      },
      clockFoot/.append style={
        line width=0.3mm
      }
    }
    
    \tikzmath{
      \R = 3mm;
      \r = 0.3mm;
      \angleHour = 90;
      \angleMinute = -45;
      \lengthHour = 0.5*\R;
      \lengthMinute = 0.9*\R;
      \earSize = 1mm;
      \angleEar = 45;
      \shiftEar = 1.1*\R;
      \lengthFoot = 1mm;
      \angleFoot= 30;
    }
  
    \def\rimColor{black}
    \def\faceColor{white}

    \node[skinny,circle,draw=\rimColor,fill=\faceColor,
    minimum size=2*\R] (cuteclock) at (0,0) {};
  
    \draw[clockHand,rotate=\angleHour] (0,0) to (\lengthHour*1pt,0);
    \draw[clockHand,rotate=\angleMinute] (0,0) to (\lengthMinute*1pt,0);

    \draw[\rimColor,fill=\rimColor] (\r*1pt,0) arc (0:360:\r*1pt);
  
    \foreach \earAngle in {-\angleEar,\angleEar} {
      \draw[\rimColor,fill=\faceColor,rotate=\earAngle,shift={(0,\shiftEar*1pt)}]
      (-\earSize*1pt,0) to (\earSize*1pt,0) arc (0:180:\earSize*1pt) to cycle;
    }
  
    \foreach \footAngle in {-\angleFoot,\angleFoot} {
      \draw[clockFoot,
      rotate=\footAngle,shift={(0,-\R*1pt)}] (0,0) to (0,-\lengthFoot*1pt);
    }
  \end{scope}
}

%%%%%%%%%%%% Arrow as a bullet point

\newcommand{\fancyarrow}{
\resizebox{!}{0.7em}{
\begin{tikzpicture}
  \tikzmath{
    \width=0.7em;
    \height=0.5em;
    \inset=0.2*\width;
  }
  \draw[line width=2mm] (0,0) to (-\inset,\height/2)
  to (-\inset+\width,0) to
  (-\inset,-\height/2) to cycle;
  \path[fill=black] (0,0) to (-\inset,\height/2) to
  (-\inset+\width,0) to cycle;
\end{tikzpicture}
}
}

%%%%%%%%%%%% Tentacle for "mind-map" style connections

\makeatletter
\define@key{tentaclekeys}{start}{\def\xys{#1}}%
\define@key{tentaclekeys}{end}{\def\xye{#1}}%
\define@key{tentaclekeys}{out}{\def\out{#1}}%
\define@key{tentaclekeys}{in}{\def\in{#1}}%
\define@key{tentaclekeys}{widthstart}{\def\ws{#1}}%
\define@key{tentaclekeys}{widthend}{\def\we{#1}}%
\define@key{tentaclekeys}{color}{\def\color{#1}}%
\makeatother
\NewEnviron{tentacle}[1][]{
  % Parameter loading
  \setkeys{tentaclekeys}{start={0,0},#1}
  \setkeys{tentaclekeys}{end={1,-1},#1}
  \setkeys{tentaclekeys}{out=-90,#1}
  \setkeys{tentaclekeys}{in=90,#1}
  \setkeys{tentaclekeys}{widthstart=1mm,#1}
  \setkeys{tentaclekeys}{widthend=0mm,#1}
  \setkeys{tentaclekeys}{color=black,#1}
  % Drawing
  \tikzset{
    tip/.append style={
      color=\color,
      fill=\color,
      line width=0.1mm
    },
    tentacle/.append style={
      color=\color,
      fill=\color,
      line width=0.1mm
    }
  }

  \tikzmath{
    \angss = \out+80;
    \angse = \out+280;
    \anges = \in-100;
    \angee = \in-280;
    \xshfts = cos(\angss)*\ws/2;
    \yshfts = sin(\angss)*\ws/2;
    \xshfte = cos(\anges)*\we/2;
    \yshfte = sin(\anges)*\we/2;
  }
  
  \coordinate (start) at (\xys);
  \coordinate (end) at (\xye);
  \coordinate (start right) at ($(start)+(\xshfts*1pt,\yshfts*1pt)$);
  \coordinate (start left) at ($(start)-(\xshfts*1pt,\yshfts*1pt)$);
  \coordinate (end right) at ($(end)+(\xshfte*1pt,\yshfte*1pt)$);
  \coordinate (end left) at ($(end)-(\xshfte*1pt,\yshfte*1pt)$);
  
  \draw[tip] (start right) arc (\angss:\angse:\ws/2);
  \draw[tip] (end right) arc (\anges:\angee:\we/2);

  \draw[tentacle] (start right) to[out=\out,in=\in] (end right)
  to (end left) to[out=\in,in=\out] (start left);
}

%%%%%%%%%%%% Helper grid

\makeatletter
\def\grd@save@target#1{%
  \def\grd@target{#1}}
\def\grd@save@start#1{%
  \def\grd@start{#1}}
\def\grdOpacity{0.5}
\tikzset{
  grid with coordinates/.style={
    to path={%
      \pgfextra{%
        \edef\grd@@target{(\tikztotarget)}%
        \tikz@scan@one@point\grd@save@target\grd@@target\relax
        \edef\grd@@start{(\tikztostart)}%
        \tikz@scan@one@point\grd@save@start\grd@@start\relax
        \draw[minor help lines] (\tikztostart) grid (\tikztotarget);
        \draw[major help lines] (\tikztostart) grid (\tikztotarget);
        \grd@start
        \pgfmathsetmacro{\grd@xa}{\the\pgf@x/1cm}
        \pgfmathsetmacro{\grd@ya}{\the\pgf@y/1cm}
        \grd@target
        \pgfmathsetmacro{\grd@xb}{\the\pgf@x/1cm}
        \pgfmathsetmacro{\grd@yb}{\the\pgf@y/1cm}
        \pgfmathsetmacro{\grd@xc}{\grd@xa + \pgfkeysvalueof{/tikz/grid with coordinates/major step}}
        \pgfmathsetmacro{\grd@yc}{\grd@ya + \pgfkeysvalueof{/tikz/grid with coordinates/major step}}
        \foreach \x in {\grd@xa,\grd@xc,...,\grd@xb}
        \node[anchor=north] at (\x,\grd@ya) {\pgfmathprintnumber{\x}};
        \foreach \y in {\grd@ya,\grd@yc,...,\grd@yb}
        \node[anchor=east] at (\grd@xa,\y) {\pgfmathprintnumber{\y}};
      }
    }
  },
  minor help lines/.style={
    help lines,
    opacity=\grdOpacity,
    step=\pgfkeysvalueof{/tikz/grid with coordinates/minor step}
  },
  major help lines/.style={
    help lines,
    opacity=\grdOpacity,
    line width=\pgfkeysvalueof{/tikz/grid with coordinates/major line width},
    step=\pgfkeysvalueof{/tikz/grid with coordinates/major step}
  },
  grid with coordinates/.cd,
  minor step/.initial=.2,
  major step/.initial=1,
  major line width/.initial=1pt
}

\newcommand{\tiklzhelpgrid}[1][7,4]{%
\def\axmax{#1}
\xdef\axmin{}
\xdef\count{1}
\foreach \val in \axmax {
\ifthenelse{\equal{\count}{1}}{
\xdef\axmin{-\val}
}{
\xdef\axmin{\axmin,-\val}
}
\xdef\count{2}
}
\draw (\axmin) to[grid with coordinates] (\axmax);
}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
