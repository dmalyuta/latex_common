%%%%%%%%%%%% Packages

\usepackage{pgfplots}
\pgfplotsset{compat=newest}

%%%%%%%%%%%% Libraries

\usetikzlibrary{math}
\usetikzlibrary{calc}
\usetikzlibrary{shapes}
\usetikzlibrary{arrows}
\usetikzlibrary{tikzmark}
\usetikzlibrary{positioning}
\usetikzlibrary{scopes}
\usetikzlibrary{shapes.multipart}
\usetikzlibrary{shapes.geometric}
\usetikzlibrary{bending}
\usetikzlibrary{decorations.markings}
\usetikzlibrary{decorations.text}
\usetikzlibrary{intersections}
\usetikzlibrary{external}

% curve through points: (A) to[curve through={(B) .. (C) .. (...)}] {Z};
% \usetikzlibrary{hobby}

%%%%%%%%%%%% Common settings

\makeatletter
\newcommand{\tiklzcommonsettings}[1][]{
  \tikzset{
    every node/.append style={
      inner sep=0,
      outer sep=0
    },
    axis/.append style={
      black,
      ->
    },
    label text/.append style={
      outer sep=1
    }
  }

  % Define 3D coordinate initial angles
  % -- (Main frame)
  \xdef\@tiklz@td@main@alt{0}
  \xdef\@tiklz@td@main@azi{0}
  \tdplotsetmaincoords{
    \@tiklz@td@main@alt}{
    \@tiklz@td@main@azi}
  % -- (Rotated frame)
  \xdef\@tiklz@td@rot@mat{{1,0,0},{0,1,0},{0,0,1}}
}
\makeatother

%%%%%%%%%%%%  Floating point calculations

\ExplSyntaxOn
\cs_set_eq:NN \fpeval \fp_eval:n
\ExplSyntaxOff

%%%%%%%%%%%% Common helper functions

\makeatletter

\def\convertto#1#2{\strip@pt\dimexpr #2*65536/\number\dimexpr 1#1}

\define@key{@dimensionalize@keys}{unit}{\def\@@@unit{#1}}
\newcommand{\dimensionalize}[2][]{%
  %
  % Append to #1 the unit \@@@unit.
  % Common use case is to append "pt" to a tikzmath output.
  %
  % -- Parameters
  \setkeys{@dimensionalize@keys}{unit=pt,#1}%
  % -- Function body
  \tikzmath{\@@@@value=#2;} % to pt
  \def\@pt@unit{pt}%
  \xdef\@@@@tmp{\@@@@value\@pt@unit} % append "pt" unit
  \xdef#2{\convertto{\@@@unit}{\@@@@tmp}\@@@unit} % convert to target unit
}

\newcommand{\rel@pos}[3][]{
  %
  % Define a position relative to a coordinate.
  %
  % Inputs
  % ------
  % #1 (optional): what to name the new coordinate (default: @rel@pos).
  % #2: relative position
  % #3: origin coordinate
  %
  % -- Function body
  \ifthenelse{\equal{#1}{}}{%
    \xdef\@@coord@name{@rel@pos}%
  }{%
    \xdef\@@coord@name{#1}%
  }%
  \coordinate (\@@coord@name) at ($#2+#3$);%
}

\makeatother

%%%%%%%%%%%% 3D coordinate system settings

\makeatletter

\define@key{coordKeys}{altitude}{\def\altitude{#1}}
\define@key{coordKeys}{azimuth}{\def\azimuth{#1}}
\newcommand{\tiklzSetViewAngle}[1][]{
  \setkeys{coordKeys}{altitude=20,#1}%
  \setkeys{coordKeys}{azimuth=40,#1}%
  \tikzmath{
    \@tiklz@td@main@alt=90-\altitude;
    \@tiklz@td@main@azi=90+\azimuth;
  }
  \tdplotsetmaincoords{
    \@tiklz@td@main@alt}{
    \@tiklz@td@main@azi}
  \xdef\@tiklz@td@main@alt{\@tiklz@td@main@alt}
  \xdef\@tiklz@td@main@azi{\@tiklz@td@main@azi}
  % View vector
  \tikzmath{
    \X = cos(\altitude)*cos(\azimuth);
    \Y = cos(\altitude)*sin(\azimuth);
    \Z = sin(\altitude);
  }
  \xdef\viewVector{\X,\Y,\Z}
  \xdef\@tiklz@tdplot@set{}
}

\define@key{@@rot@keys}{yaw}{\def\@yaw{#1}}
\define@key{@@rot@keys}{pitch}{\def\@pitch{#1}}
\define@key{@@rot@keys}{roll}{\def\@roll{#1}}
\define@key{@@rot@keys}{reset}{\def\@reset{#1}}
\newcommand{\tiklzSetRotatedCoord}[1][]{
  \setkeys{@@rot@keys}{yaw=0,#1}
  \setkeys{@@rot@keys}{pitch=0,#1}
  \setkeys{@@rot@keys}{roll=0,#1}
  \setkeys{@@rot@keys}{reset=false,#1}
  % Compute rotation matrix
  \tikzmath{
    \@cy = cos(\@yaw);
    \@sy = sin(\@yaw);
    \@cp = cos(\@pitch);
    \@sp = sin(\@pitch);
    \@cr = cos(\@roll);
    \@sr = sin(\@roll);
  }
  \def\@Rz{{\@cy,-\@sy,0},{\@sy,\@cy,0},{0,0,1}}
  \def\@Ry{{\@cp,0,\@sp},{0,1,0},{-\@sp,0,\@cp}}
  \def\@Rx{{1,0,0},{0,\@cr,-\@sr},{0,\@sr,\@cr}}
  \matrix@mult{\@Ry}{\@Rx}
  \matrix@mult{\@Rz}{\@matrix}
  \ifthenelse{\equal{\@reset}{false}}{
    \matrix@mult{\@tiklz@td@rot@mat}{\@matrix}
  }{}
  \xdef\@tiklz@td@rot@mat{\@matrix}
  % Extract the roll, pitch and yaw
  % Source: https://www.learnopencv.com/rotation-matrix-to-euler-angles/
  \matrix@get[@a]{\@tiklz@td@rot@mat}{1}{1}
  \matrix@get[@b]{\@tiklz@td@rot@mat}{2}{1}
  \tikzmath{\@sy=\fpeval{sqrt((\@a)^2+(\@b)^2)};}
  \pgfmathparse{\@sy<1e-4 ? 1:0}
  \ifthenelse{\pgfmathresult>0}{
    \matrix@get[@c]{\@tiklz@td@rot@mat}{2}{3}
    \matrix@get[@d]{\@tiklz@td@rot@mat}{2}{2}
    \matrix@get[@e]{\@tiklz@td@rot@mat}{3}{1}
    \tikzmath{
      \@roll = atan2(-\@c,\@d);
      \@pitch = atan2(-\@e,\@sy);
      \@yaw = 0;
    }
  }{
    \matrix@get[@c]{\@tiklz@td@rot@mat}{3}{2}
    \matrix@get[@d]{\@tiklz@td@rot@mat}{3}{3}
    \matrix@get[@e]{\@tiklz@td@rot@mat}{3}{1}
    \tikzmath{
      \@roll = atan2(\@c,\@d);
      \@pitch = atan2(-\@e,\@sy);
      \@yaw = atan2(\@b,\@a);
    }
  }
  \xdef\@yaw{\@yaw}
  \xdef\@pitch{\@pitch}
  \xdef\@roll{\@roll}
  % Set the rotated frame
  \convertTaitBryanToTikZ{\@yaw}{\@pitch}{\@roll}
  \tdplotsetrotatedcoords{\TikZalpha}{\TikZbeta}{\TikZgamma}
}

\makeatother

%%%%%%%%%%%% Circle, partitioned into 2 if needed for cylinder drawing

\makeatletter
\define@key{@@circle@keys}{name}{\def\@name{#1}}
\define@key{@@circle@keys}{center}{\def\@center{#1}}
\define@key{@@circle@keys}{radius}{\def\@radius{#1}}
\define@key{@@circle@keys}{split}{\def\@split{#1}}
\define@key{@@circle@keys}{styles}{\def\@styles{#1}}
\newcommand{\tiklz@circle}[1]{
  %
  % Draw a (partitioned) circle.
  %
  % Parameters
  % ----------
  %   center : circle center coordinates (default: 0,0).
  %   radius : circle radius (default: 1).
  %   split : tuple (start,end) angles at which to make the cut of the circle into
  %           two halves.
  %   styles : single or tuple, for each circle partition.
  %
  % -- Parameters
  \setkeys{@@circle@keys}{name=circle,#1}
  \setkeys{@@circle@keys}{center={0,0},#1}
  \setkeys{@@circle@keys}{radius=1,#1}
  \setkeys{@@circle@keys}{styles=,#1}
  \setkeys{@@circle@keys}{split=,#1}
  % -- Function body
  \ifthenelse{\equal{\@split}{}}{
    \draw[\@styles] (\@center) circle (\@radius);
  }{
    \list@get[@@ang@start]{\@split}{1}
    \list@get[@@ang@end]{\@split}{2}

    \list@get[@@style@one]{\@styles}{1}
    \list@size{\@styles}
    \ifthenelse{\equal{\@list@size}{1}}{
      \xdef\@@style@two{\@@style@one}
    }{
      \list@get[@@style@two]{\@styles}{2}
    }
    % Naming
    \xdef\@@@one{@one}
    \xdef\@@@two{@two}
    \xdef\@@@one@r{@one@r}
    \xdef\@@@two@r{@two@r}
    % First half
    \edef\p@one{\@name_p1}
    \edef\p@one@r{\@name_p1r}
    \coordinate (\p@one) at ($(\@center)+(\@@ang@start:\@radius)$);
    \coordinate (\p@one@r) at ($(\@center)+(\@@ang@end:\@radius)$);
    \expandafter\xdef\csname \@name\@@@one\endcsname{
      (\p@one) arc (\@@ang@start:\@@ang@end:\@radius)
    }
    \expandafter\xdef\csname \@name\@@@one@r\endcsname{
      (\p@one@r) arc (\@@ang@end:\@@ang@start:\@radius)
    }
    \draw[\@@style@one] \csname\@name\@@@one\endcsname;
    % Second half
    \edef\p@two{\@name_p2}
    \edef\p@two@r{\@name_p2r}
    \coordinate (\p@two) at ($(\@center)+(\@@ang@end:\@radius)$);
    \coordinate (\p@two@r) at ($(\@center)+(360+\@@ang@start:\@radius)$);
    \expandafter\xdef\csname \@name\@@@two\endcsname{
      (\p@two) arc (\@@ang@end:360+\@@ang@start:\@radius)
    }
    \expandafter\xdef\csname \@name\@@@two@r\endcsname{
      (\p@two@r) arc (360+\@@ang@start:\@@ang@end:\@radius)
    }
    \draw[\@@style@two] \csname\@name\@@@two\endcsname;
  }
}
\makeatother

%%%%%%%%%%%% "Loop" block (used in ARC 2020 survey paper with Yue Yu)

\makeatletter
\define@key{loopKeys}{position}{\def\position{#1}}%
\define@key{loopKeys}{title}{\def\title{#1}}%
\define@key{loopKeys}{text}{\def\text{#1}}%
\define@key{loopKeys}{height}{\def\height{#1}}%
\define@key{loopKeys}{width}{\def\width{#1}}%
\define@key{loopKeys}{textalign}{\def\textalign{#1}}%
\define@key{loopKeys}{bgcolor}{\def\bgcolor{#1}}%
\define@key{loopKeys}{arrowcolor}{\def\arrowcolor{#1}}%
\newcommand{\loopblock}[1][]{
  % Parameters
  \setkeys{loopKeys}{position=,#1}%
  \setkeys{loopKeys}{title=,#1}%
  \setkeys{loopKeys}{text=,#1}%
  \setkeys{loopKeys}{height=20mm,#1}%
  \setkeys{loopKeys}{width=40mm,#1}%
  \setkeys{loopKeys}{textalign=middle,#1}% middle,top
  \setkeys{loopKeys}{bgcolor=black!30,#1}% middle,top
  \setkeys{loopKeys}{arrowcolor=black,#1}% middle,top
  %
  % Draw
  % -- Dimensions
  \def\@loop@sw@sep{3mm}
  \def\@loop@corner@radius{3mm}
  \def\@loop@linewidth{1mm}
  \def\@loop@arrow@left@pad{1mm}
  \def\@loop@title@pad{1mm}
  \def\@loop@area@text@pad{2mm}
  % -- Styles
  \tiklzcommonsettings
  \tikzset{
    loop arrow/.append style={
      -latex,
      line width=0.6mm,
      line cap=round
    },
    loop bg/.append style={
      line cap=round
    },
    loop title/.append style={
      align=left,
      anchor=west,
      font={\bfseries\small},
      outer sep=\@loop@title@pad
    },
    loop area text/.append style={
      rectangle,
      minimum width=\width-2*\@loop@corner@radius,
      text width=\width-2*\@loop@corner@radius,
      % draw=black,
      align=left,
      font={\footnotesize}
    }
  }
  \begin{scope}[shift={\position}]
    % -- Title
    \node[loop title] (loop title) at (0,0) {\title};
    % Measure title height and width
    \path let
    \p1=(loop title.east),
    \p2=(loop title.south east),
    \p3=(loop title.west)
    in \pgfextra{
      \tikzmath{\@loop@title@height = \y1-\y2;}
      \tikzmath{\@loop@title@width = \x1-\x3;}
      \dimensionalize{\@loop@title@height}
      \dimensionalize{\@loop@title@width}
    };
    % Starting point for arrow
    \coordinate (loop arrow start) at
    ($(loop title.south west)+(\@loop@arrow@left@pad+\@loop@title@pad,0)$);
    % -- Loop area background
    \path[
    loop bg,
    fill=\bgcolor
    ] (loop arrow start) -- node[pos=0.5](loop@area@middle@vertical){}
    ++(0,-\height+\@loop@title@height+\@loop@corner@radius)
    arc (180:270:\@loop@corner@radius)
    -- node[pos=0.5](loop@area@middle@horizontal){}
    ++(\width-\@loop@corner@radius*2,0)
    arc (-90:0:\@loop@corner@radius)
    -- ++(0,{\height-2*\@loop@corner@radius})
    arc (0:90:\@loop@corner@radius)
    -- (loop title.east)
    -- (loop title.south east)
    --cycle;
    % -- Loop area perimeter arrow
    \draw[
    loop arrow,
    draw=\arrowcolor
    ] (loop arrow start) --
    ++(0,-\height+\@loop@title@height+\@loop@corner@radius)
    arc (180:270:\@loop@corner@radius)
    -- ++(\width-\@loop@corner@radius*2,0)
    arc (-90:0:\@loop@corner@radius)
    -- ++(0,{\height-2*\@loop@corner@radius})
    arc (0:90:\@loop@corner@radius)
    -- (loop title.east);
    % -- Loop area text
    \path let
    \p1=(loop@area@middle@vertical),
    \p2=(loop@area@middle@horizontal),
    \p3=(loop title.south)
    in \pgfextra{
      \ifthenelse{\equal{\textalign}{middle}}{
        \coordinate (loop_area_middle) at (\x2,\y1-\@loop@corner@radius/2);
        \node[loop area text] at (loop_area_middle) {\text};
      }{
        \coordinate (loop_area_top) at (\x2,\y3-\@loop@area@text@pad);
        \node[loop area text,anchor=north] at (loop_area_top) {\text};
      } 
    };
  \end{scope}
}
\makeatother

%%%%%%%%%%%% Selector Simulink-like block

\newcommand{\selector}[1]{
  % #1 : list of input i/output j connections, e.g. 1/1,2/,3/2 for 3-input
  %      2-output selector with mapping 1->1,3->2.
  \def\connections{#1}
  \xdef\Nu{0}
  \xdef\No{0}
  \foreach \i/\j in \connections {
    \tikzmath{\Nu=int(\Nu+1);}
    \ifthenelse{\equal{\j}{}}{}{
      \tikzmath{\No=int(\No+1);}
    }
    \xdef\Nu{\Nu}
    \xdef\No{\No}
  }
  
  \tikzmath{
    \elsz = 2;
    \elsep = 4;
    \blkh = (\Nu+0.5)*\elsep;
    \blkw = 8*\elsz;
  }

  \tikzset{
    every node/.append style={
      inner sep=0,
      outer sep=0
    },
    element/.append style={
      draw=black,
      rectangle,
      minimum size=\elsz pt
    },
    block/.append style={
      rectangle,
      draw=black,
      fill=white,
      minimum width=\blkw pt,
      minimum height=\blkh pt
    }
  }

  \node[block] (selector) at (0,0) {};

  \path let \p1=(selector.center) in \pgfextra{
    \xdef\k{0}
    \foreach \i/\j/\name in \connections {
      \tikzmath{
        \elux = \x1-\blkw/2+\elsz*3/2;
        \eluy = \y1+\elsep*(\Nu-1)/2-(\i-1)*\elsep;
      }
      \ifthenelse{\equal{\j}{}}{
        \node[element=white] at (\elux pt,\eluy pt) {};
      }{
        \tikzmath{
          \k = int(\k+1);
          \elox = \x1+\blkw/2-\elsz*3/2;
          \eloy = \y1+\elsep*(\No-1)/2-(\k-1)*\elsep;
        }
        \node[element,fill=black] (input) at (\elux pt,\eluy pt) {};
        \node[element,fill=black] (output) at (\elox pt,\eloy pt) {};
        \ifthenelse{\equal{\name}{}}{
          \draw (input.east) -- (output.west);
        }{
          \draw (input.east) --
          node[pos=0.5,circle,fill=white,scale=0.4,inner sep=0.5mm]{\name}
          (output.west);
        }
        
        \xdef\k{\k}
      }
    }
  };
}

%%%%%%%%%%%% Multicolor line (dashed)

\newcommand{\multicolorline}[5]{
  % #1: origin
  % #2: destination
  % #3: (origin) <INSERT #3> (destination)
  % #4: colors list
  % #5: line style
  \xdef\dashunit{pt}
  \xdef\dashlength{3}
  \xdef\dashstep{-\dashlength}
  \xdef\colorcount{0}
  \foreach \color in {#4} {
    \tikzmath{
      \dashstep=\dashstep+\dashlength;
      \colorcount=int(\colorcount+1);
    }
    \xdef\dashstep{\dashstep}
    \xdef\colorcount{\colorcount}
  }
  \path[draw=none] (#1) #3 node[pos=1](multicolorlinedestination){} (#2);
  \node[outer sep=1mm] (multicolorlinedestination) at (multicolorlinedestination) {};
  \foreach \color [count=\i] in {#4} {
    \pgfmathparse{\i==\colorcount ? 1:0}
    \ifthenelse{\pgfmathresult>0}{
      \xdef\colorlast{\color}
    }{
      \tikzmath{\dashphase=int(\dashlength*(\i-1));}
      \draw[#5,
      -,
      draw=\color,
      dash pattern=on \dashlength\dashunit off \dashstep\dashunit,
      dash phase=\dashphase\dashunit] (#1) #3 (multicolorlinedestination);
    }
  }
  \draw[#5,
  draw=\colorlast,
  dash pattern=on \dashlength\dashunit off \dashstep\dashunit,
  dash phase=\dashstep\dashunit] (#1) #3 (#2);
}

%%%%%%%%%%%% Ellipsoid

\makeatletter
\define@key{ellipseKeys}{x}{\def\x{#1}}
\define@key{ellipseKeys}{y}{\def\y{#1}}
\define@key{ellipseKeys}{maj}{\def\maj{#1}}
\define@key{ellipseKeys}{min}{\def\min{#1}}
\define@key{ellipseKeys}{rot}{\def\rot{#1}}
\define@key{ellipseKeys}{style}{\def\style{#1}}
\define@key{ellipseKeys}{name}{\def\name{#1}}
\makeatother
\newcommand{\ellipse}[1][]{
  \setkeys{ellipseKeys}{x=0,#1}%
  \setkeys{ellipseKeys}{y=0,#1}%
  \setkeys{ellipseKeys}{min=1,#1}%
  \setkeys{ellipseKeys}{maj=2,#1}%
  \setkeys{ellipseKeys}{rot=0,#1}%
  \setkeys{ellipseKeys}{style={},#1}%
  \setkeys{ellipseKeys}{name=ellipse,#1}%
  \node[
  \style,
  inner sep=0,
  outer sep=0,
  ellipse,
  minimum width=\min*1cm,
  minimum height=\maj*1cm,
  rotate=\rot] (\name) at (\x,\y) {};
}

%%%%%%%%%%%% Quadrotor

\newcommand{\sphereCoord}[2]{
  % return x,y,z a point on a sphere
  % #1: sphere radius
  % #2: azimuth angle, altitude angle
  \tikzmath{
    \X = #1*cos({#2}[1])*cos({#2}[0]);
    \Y = #1*cos({#2}[1])*sin({#2}[0]);
    \Z = #1*sin({#2}[1]);
  }
}

\newcommand{\convertTaitBryanToTikZ}[3]{
  % set (\TikZalpha,\TikZbeta,\TikZgamma) the coordinates to
  % tdplotsetrotatedcoords
  \pgfmathsetmacro\yaw{#1}
  \pgfmathsetmacro\pitch{#2}
  \pgfmathsetmacro\roll{#3}
  \tikzmath{
    \degToRad = \fpeval{pi/180};
    \radToDeg = \fpeval{180/pi};
    \TBpsi = \yaw*\degToRad;
    \TBtheta = \pitch*\degToRad;
    \TBphi = \roll*\degToRad;
    % 
    \TikZbeta = \fpeval{acos(cos(\TBtheta)*cos(\TBphi))};
    \TikZalpha = 0;
    \TikZgamma = 0;
  }
  \pgfmathparse{abs(\TikZbeta)<1e-4 ? 1:0}
  \ifthenelse{\pgfmathresult>0}{
    % Gimbal lock
    \tikzmath{
      \TikZgamma = 0;
      \TikZalpha = \fpeval{\TBpsi};
    }
  }{
    % Normal operation
    \tikzmath{
      \TikZgamma =
      atan2(\fpeval{cos(\TBtheta)*sin(\TBphi)},\fpeval{sin(\TBtheta)})*
      \degToRad;
      \TikZalpha = atan2(
      \fpeval{cos(\TBphi)*sin(\TBpsi)*sin(\TBtheta)-cos(\TBpsi)*sin(\TBphi)},
      \fpeval{sin(\TBpsi)*sin(\TBphi)+cos(\TBpsi)*cos(\TBphi)*sin(\TBtheta)})*\degToRad;
    }
  }
  \tikzmath{
    \TikZalpha = \TikZalpha*\radToDeg;
    \TikZbeta = \TikZbeta*\radToDeg;
    \TikZgamma = \TikZgamma*\radToDeg;
  }
  \xdef\TikZalpha{\TikZalpha}
  \xdef\TikZbeta{\TikZbeta}
  \xdef\TikZgamma{\TikZgamma}
}

\makeatletter
\define@key{droneKeysNew}{yaw}{\def\yaw{#1}}
\define@key{droneKeysNew}{pitch}{\def\pitch{#1}}
\define@key{droneKeysNew}{roll}{\def\roll{#1}}
\define@key{droneKeysNew}{x}{\def\x{#1}}
\define@key{droneKeysNew}{y}{\def\y{#1}}
\define@key{droneKeysNew}{scale}{\def\scale{#1}}
\define@key{droneKeysNew}{layers}{\def\layers{#1}}
\define@key{droneKeysNew}{showaxes}{\def\showaxes{#1}}
\makeatother
\xdef\QuadCounter{1}
\newcommand{\quadrotor}[1][]{
  \setkeys{droneKeysNew}{yaw=0,#1}%
  \setkeys{droneKeysNew}{pitch=0,#1}%
  \setkeys{droneKeysNew}{roll=0,#1}%
  \setkeys{droneKeysNew}{x=0,#1}%
  \setkeys{droneKeysNew}{y=0,#1}%
  \setkeys{droneKeysNew}{scale=1,#1}%
  \setkeys{droneKeysNew}{showaxes=false,#1}%
  \setkeys{droneKeysNew}{layers={AFR,ARR,ARL,BH,AFL,RFR,RFL,RRR,RRL},#1}%
  % Parameters
  \tikzmath{
    \Larm = 1;
    \Rr = 0.9;
    \armNorm = sqrt(2)*\Larm;
    \rx1 = \Larm;
    \ry1 = \Larm;
    \rx2 = \Larm;
    \ry2 = -\Larm;
    \rx3 = -\Larm;
    \ry3 = -\Larm;
    \rx4 = -\Larm;
    \ry4 = \Larm;
    \armwidth=0.40mm*\scale;
    \rotorlinewidth=0.40mm*\scale;
    \hubsize=\scale*0.15mm;
  }
  \def\frontRotorInnerColor{orange!100}
  \def\frontRotorOuterColor{orange!40}
  \def\frontRearInnerColor{black!40}
  \def\frontRearOuterColor{black!5}
  \tikzset{
    rotor/.append style={
      shading=radial,
      line width=\rotorlinewidth,
      fill opacity=0.8
    }
  }
  \convertTaitBryanToTikZ{\yaw}{\pitch}{\roll}
  % Plot quad
  \tdplotsetrotatedcoords{\TikZalpha}{\TikZbeta}{\TikZgamma}
  \begin{scope}[
    shift={(\x,\y)},
    tdplot_rotated_coords,
    scale=\scale]
    % Axes
    \ifthenelse{\equal{\showaxes}{}}{
      \draw[->,red] (0,0,0) -- (1,0,0);
      \draw[->,green] (0,0,0) -- (0,1,0);
      \draw[->,blue] (0,0,0) -- (0,0,1);
    }{}
    % Arms
    \expandafter\newsavebox\csname AFR\QuadCounter\endcsname
    \expandafter\newsavebox\csname AFL\QuadCounter\endcsname
    \expandafter\newsavebox\csname ARR\QuadCounter\endcsname
    \expandafter\newsavebox\csname ARL\QuadCounter\endcsname
    \foreach \i/\name in {1/FL,2/FR,3/RR,4/RL} {
      \begin{lrbox}{\csname A\name\QuadCounter\endcsname}
        \tikzmath{
          \armX = \rx\i/(\armNorm)*\hubsize;
          \armY = \ry\i/(\armNorm)*\hubsize;
        }
        \draw[line width=\armwidth]
        (\armX,\armY,0) to (\rx\i,\ry\i,0);
      \end{lrbox}
      \global%
      \expandafter\setbox\csname A\name\QuadCounter\endcsname%
      \expandafter\box\csname A\name\QuadCounter\endcsname%
    }
    % Electronics hub
    \expandafter\newsavebox\csname BH\QuadCounter\endcsname
    \begin{lrbox}{\csname BH\QuadCounter\endcsname}
      \node[
      circle,
      shading=radial,
      outer color=black!100,
      inner color=black!10,
      minimum size=\hubsize*1cm,
      inner sep=0
      ] at (0,0,0) {};
    \end{lrbox}
    % Rotors
    \expandafter\newsavebox\csname RFR\QuadCounter\endcsname
    \expandafter\newsavebox\csname RFL\QuadCounter\endcsname
    \expandafter\newsavebox\csname RRR\QuadCounter\endcsname
    \expandafter\newsavebox\csname RRL\QuadCounter\endcsname
    % Rotor 1
    \begin{lrbox}{\csname RFL\QuadCounter\endcsname}
      \begin{scope}[shift={(\rx1,\ry1)}]
        \draw[
        rotor,
        outer color=\frontRotorOuterColor,
        inner color=\frontRotorInnerColor]
        (0,0) circle (\Rr);
      \end{scope}
    \end{lrbox}
    % Rotor 2
    \begin{lrbox}{\csname RFR\QuadCounter\endcsname}
      \begin{scope}[shift={(\rx2,\ry2)}]
        \draw[
        rotor,
        outer color=\frontRotorOuterColor,
        inner color=\frontRotorInnerColor]
        (0,0) circle (\Rr);
      \end{scope}
    \end{lrbox}            
    % Rotor 3
    \begin{lrbox}{\csname RRR\QuadCounter\endcsname}
      \begin{scope}[shift={(\rx3,\ry3)}]
        \draw[
        rotor,
        outer color=\frontRearOuterColor,
        inner color=\frontRearInnerColor]
        (0,0) circle (\Rr);
      \end{scope}
    \end{lrbox}                        
    % Rotor 4
    \begin{lrbox}{\csname RRL\QuadCounter\endcsname}
      \begin{scope}[shift={(\rx4,\ry4)}]
        \draw[
        rotor,
        outer color=\frontRearOuterColor,
        inner color=\frontRearInnerColor]
        (0,0) circle (\Rr);
      \end{scope}
    \end{lrbox}
    % Now draw everything
    \foreach \obj in \layers {
      \expandafter\usebox\csname \obj\QuadCounter\endcsname
    }
  \end{scope}
  \tikzmath{\QuadCounter=int(\QuadCounter+1);}
  \xdef\QuadCounter{\QuadCounter}
}

%%%%%%%%%%%% Masten Xombie rocket

\makeatletter

\define@key{@xombie@keys}{pos}{\def\@pos{#1}}
\define@key{@xombie@keys}{tilt}{\def\@tilt{#1}}
\define@key{@xombie@keys}{gimbal}{\def\@gimbal{#1}}
\define@key{@xombie@keys}{scale}{\def\@scale{#1}}
\newcommand{\xombie}[1][]{
  \setkeys{@xombie@keys}{pos={0,0},#1}
  \setkeys{@xombie@keys}{tilt=0,#1}
  \setkeys{@xombie@keys}{gimbal=0,#1}
  \setkeys{@xombie@keys}{scale=1,#1}

  \xdef\@gold{yellow!85!black}
  \xdef\@silver{black!20}
  \xdef\@silver@darker{black!50}
  \xdef\@fuel@duct{black}
  \xdef\@radiator@top{black!70}
  \xdef\@radiator@bottom{orange}
  \xdef\@engine@cnxn{black!70}
  \xdef\@engine@nozzle{black}
  \xdef\@flame@inner{yellow}
  \xdef\@flame{orange}
  \xdef\@flame@outer{red}
  \xdef\@tank{black!30}

  \tikzset{
    leg outer/.append style={
      black!60!white,
      line width=\@scale*0.6mm
    },
    leg inner/.append style={
      black!40!white,
      line width=\@scale*0.3mm
    },
    tank welds/.append style={
      line width=\@scale*0.3mm,
      black!90
    },
    top bulkhead/.append style={
      line width=\@scale*0.5mm,
      black!90
    },
    yellow bars/.append style={
      yellow!80!black,
      line width=\@scale*0.4mm
    },
    radiator vent/.append style={
      line width=\@scale*0.05mm
    }
  }

  \coordinate (Shift) at (\@pos);
  \tdplotsetrotatedcoordsorigin{(Shift)}
  \tiklzSetRotatedCoord[yaw=\@tilt]
  \begin{scope}[tdplot_rotated_coords,scale=\@scale,
    line width=\@scale*1pt]
    % External tank rear
    \coordinate (Shift) at (0.75,0,0);
    \tdplotsetrotatedcoordsorigin{(Shift)}
    \begin{scope}[tdplot_rotated_coords]
      \fill[\@tank] (-0.45,-0.1)
      -- (-0.05,-0.1) -- (-0.05,0.95)
      -- (-0.45,0.95) --cycle;
      \fill[\@tank] (-0.45,-0.1) arc (-180:0:0.2 and 0.15);
      \fill[\@tank] (-0.45,0.95) arc (180:0:0.2 and 0.15);
      \draw[tank welds] (-0.45,-0.1) -- ++(0.4,0);
      \draw[tank welds] (-0.45,0.95) -- ++(0.4,0);
    \end{scope}

    % Rear leg
    \draw[leg outer] (-0.05,-0.2) -- (-0.35,-1.8);
    \draw[leg inner] (0.,-0.7) -- (-0.325,-1.7);
    \draw[leg inner] (-0.2,-0.7) -- (-0.325,-1.7);

    % Engine nozzle
    \def\@nozzle@width{0.2}
    \def\@nozzle@height{0.35}
    \def\@flame@height@inner{0.2}
    \def\@flame@height{0.5}
    \def\@flame@height@outer{0.8}
    \coordinate (Shift) at (0.05,-0.95,0);
    \tdplotsetrotatedcoordsorigin{(Shift)}
    \tiklzSetRotatedCoord[yaw=\@gimbal]
    \begin{scope}[tdplot_rotated_coords]
      \fill[\@flame@outer] (-\@nozzle@width/2,-\@nozzle@height)
      -- (0,-\@nozzle@height-\@flame@height@outer)
      -- (\@nozzle@width/2,-\@nozzle@height);
      \fill[\@flame] (-\@nozzle@width/2,-\@nozzle@height)
      -- (0,-\@nozzle@height-\@flame@height)
      -- (\@nozzle@width/2,-\@nozzle@height);
      \fill[\@flame@inner] (-\@nozzle@width/2,-\@nozzle@height)
      -- (0,-\@nozzle@height-\@flame@height@inner)
      -- (\@nozzle@width/2,-\@nozzle@height);
      
      \draw[fill=\@engine@nozzle] (\@nozzle@width/2,0)
      -- (-\@nozzle@width/2,0)
      -- (-\@nozzle@width/2,-\@nozzle@height)
      -- (\@nozzle@width/2,-\@nozzle@height)
      --cycle;
    \end{scope}
    \tiklzSetRotatedCoord[yaw=-\@gimbal]

    % Bottom (engine) bulkhead
    \draw[fill=\@gold] (-0.45,-0.65) arc (-180:0:0.5 and 0.3);

    % Engine top housing
    \draw[fill=\@engine@cnxn] (-0.15,-0.9)
    arc (-180:0:0.2 and 0.04) -- ++(0,-0.1) 
    arc (0:-180:0.2 and 0.02) --cycle;

    % Bottom tank walls
    \draw[fill=\@gold] (-0.45,-0.65)
    -- (0.55,-0.65)
    -- (0.55,0)
    -- (-0.45,0)
    --cycle;
    
    % Center tank walls
    \draw[fill=\@silver@darker] (-0.45,0)
    -- (0.55,0)
    -- (0.55,1)
    -- (-0.45,1)
    --cycle;

    % Left leg
    \draw[leg inner] (-0.4,-0.7) -- (-1.425,-1.7);
    \draw[leg inner] (-0.3,-0.7) -- (-1.425,-1.7);

    % Right leg
    \draw[leg inner] (0.425,-0.7) -- (1.425,-1.7);
    \draw[leg inner] (0.35,-0.7) -- (1.425,-1.7);

    % Front leg
    \draw[leg inner] (0.,-0.7) -- (0.425,-1.7);
    \draw[leg inner] (0.15,-0.7) -- (0.425,-1.7);
    \draw[leg outer] (0.1,-0.2) -- (0.45,-1.8);

    % Left leg
    \draw[leg outer] (-0.4,-0.2) -- (-1.5,-1.8);

    % Right leg
    \draw[leg outer] (0.45,-0.2) -- (1.5,-1.8);

    % Top tank bulkhead
    \draw[fill=\@silver] (-0.45,1) arc (180:0:0.5 and 0.3);
    
    % Bars connecting to top bulkhead
    \draw[yellow bars] (-0.4,1) -- ++(0,0.75);
    \draw[yellow bars] (-0.25,1) -- ++(0,0.75);
    \draw[yellow bars] (0,1) -- ++(0,0.75);
    \draw[yellow bars] (0.35,1) -- ++(0,0.75);
    \draw[yellow bars] (0.45,1) -- ++(0,0.75);

    % Payload bottom bulkhead
    \draw[top bulkhead] (-0.45,1.3) -- ++(1,0);

    % Middle bulkhead
    \draw[top bulkhead] (-0.45,1) -- (0.55,1);
    
    % Middle bottom bulkhead
    \draw[top bulkhead] (-0.45,0) -- (0.55,0);

    % External tank front
    \fill[\@tank] (-0.45,-0.1)
    -- (-0.05,-0.1) -- (-0.05,0.95)
    -- (-0.45,0.95) --cycle;
    \fill[\@tank] (-0.45,-0.1) arc (-180:0:0.2 and 0.15);
    \fill[\@tank] (-0.45,0.95) arc (180:0:0.2 and 0.15);
    \draw[tank welds] (-0.45,-0.1) -- ++(0.4,0);
    \draw[tank welds] (-0.45,0.95) -- ++(0.4,0);

    % Top bulkhead
    \draw[top bulkhead] (-0.45,1.75) -- (0.55,1.75);

    % Side fuel duct
    \fill[\@fuel@duct] (0.25,-0.55)
    -- ++(0.1,0) -- ++(0,1.45) --
    ++(-0.1,0) --cycle;
    \fill[\@fuel@duct] (0.25,-0.55)
    arc (-180:0:0.05);
    \fill[\@fuel@duct] (0.25,0.9)
    arc (180:0:0.05);

    % Radiator top
    \def\@radiator@vstep{0.02}
    \def\@radiator@width{0.2}
    \foreach \@i in {1,...,8} {
      \tikzmath{
        \@y = 0.9-(\@i-1)*\@radiator@vstep;
      }
      \draw[radiator vent,\@radiator@top]
      (0,\@y) -- ++(\@radiator@width,0);
    }
    
    % Radiator bottom
    \def\@radiator@vstep{0.02}
    \def\@radiator@width{0.4}
    \foreach \@i in {1,...,8} {
      \tikzmath{
        \@y = -0.4-(\@i-1)*\@radiator@vstep;
      }
      \draw[radiator vent,\@radiator@bottom]
      (-0.4,\@y) -- ++(\@radiator@width,0);
    }
  \end{scope}
  \tiklzSetRotatedCoord[yaw=-\@tilt]

  
  
  % \begin{scope}[
  %   shift={\@pos},
  %   rotate=\@tilt,
  %   xshift=-0.05cm]    
    
  % \end{scope}
}

\makeatother

%%%%%%%%%%%% Vector difference

\newcommand{\vectorDiff}[2]{
  % return the difference a - b
  % #1: vector a
  % #2: vector b
  \tikzmath{
    \X = {#1}[0]-{#2}[0];
    \Y = {#1}[1]-{#2}[1];
    \Z = {#1}[2]-{#2}[2];
  }
}

%%%%%%%%%%%% Vector dot product

\newcommand{\dotProduct}[2]{
  % return the dot product a . b
  % #1: vector a
  % #2: vector b
  \tikzmath
  {
    \OUT = {#1}[0]*{#2}[0]+{#1}[1]*{#2}[1]+{#1}[2]*{#2}[2];
  }
}

%%%%%%%%%%%% Vector cross product

\newcommand{\crossProduct}[2]{
  % return the cross product a x b
  % #1: vector a
  % #2: vector b
  \tikzmath
  {
    \X = {#1}[1]*{#2}[2]-{#1}[2]*{#2}[1];
    \Y = {#1}[2]*{#2}[0]-{#1}[0]*{#2}[2];
    \Z = {#1}[0]*{#2}[1]-{#1}[1]*{#2}[0];
  }
}

%%%%%%%%%%%% Rocket lander

\makeatletter
\define@key{rocketKeys}{shift}{\def\shift{#1}}
\define@key{rocketKeys}{legs}{\def\legs{#1}}
\define@key{rocketKeys}{fire}{\def\fire{#1}}
\makeatother
\newcommand{\rocket}[1][]{
  \setkeys{rocketKeys}{shift={(0,0)},#1}%
  \setkeys{rocketKeys}{legs=out,#1}%
  \setkeys{rocketKeys}{fire=false,#1}%
  \begin{scope}[shift={\shift}]
    \ifthenelse{\equal{\legs}{out}}{
      \tikzmath{\lAng = 60;}
    }{
      \tikzmath{\lAng = 180;}
    }
    \tikzmath{
      % User
      \rL = 2;
      \rW = 0.3;
      \lL = 0.6;
      \lW = 0.1;
      \lCF = 0.2;
      \lCH = 0.15;
      \eW = 0.3*\rW;
      \eH = 0.07;
      \eAng = 30;
      \eBellOutAng = -30;
      \eBellInAng = 90;
      \fH = 0.4;
      % Derived
      \lX = \lL*sin(\lAng);
      \lH = \lL*cos(\lAng);
      \eX = \eH*tan(\eAng);
    }
    \tikzset{
      every node/.append style={
        inner sep=0,
        outer sep=0
      },
      fuselage/.append style={
        rectangle,
        draw=black,
        minimum width=\rW cm,
        minimum height=\rL cm,
        shading=axis,
        shading angle=0,
        left color=white,
        right color=gray
      },
      leg/.append style={
        fill=black,
        draw=black,
        line join=bevel
      },
      leg cylinder/.append style={
        black,
        line width=0.2mm
      },
      engine bell/.append style={
        draw=black,
        shading=axis,
        shading angle=0,
        left color=gray,
        right color=black
      },
      engine fire/.append style={
        shading=axis,
        top color=orange,
        bottom color=yellow,
        draw=none
      }
    }
    \node[fuselage] (body) at (0,0) {};

    \draw[leg] (body.south west) to ++(-\lX,-\lH) to
    node[pos=\lCF](cylinder left){} ++(\lX,\lH+\lW) -- cycle;
    \draw[leg] (body.south east) to ++(\lX,-\lH) to
    node[pos=\lCF](cylinder right){} ++(-\lX,\lH+\lW) -- cycle;

    \draw[leg cylinder] ($(body.south west)+(0,\lW+\lCH)$)
    to (cylinder left);
    \draw[leg cylinder] ($(body.south east)+(0,\lW+\lCH)$)
    to (cylinder right);

    \coordinate (engine south east) at ($(body.south)+(\eW/2+\eX,-\eH)$);
    \coordinate (engine south west) at ($(body.south)+(-\eW/2-\eX,-\eH)$);
    
    \ifthenelse{\equal{\fire}{true}}{
      \draw[engine fire] (engine south east) to ++(-\eW/2-\eX,-\fH) to
      (engine south west) --cycle;
    }{}

    \draw[engine bell] (body.south) to ++(\eW/2,0)
    to[out=\eBellOutAng,in=\eBellInAng] ++(\eX,-\eH)
    to ++(-\eW-2*\eX,0)
    to[out=\eBellInAng,in=-180-\eBellOutAng] ++(\eX,\eH)
    --cycle;
  \end{scope}
}

%%%%%%%%%%%% Center of gravity

\makeatletter
\define@key{cgKeys}{sz}{\def\@cg@radius{#1}}
\define@key{cgKeys}{pos}{\def\shift{#1}}
\newcommand{\cg}[1][]{
  \setkeys{cgKeys}{sz=0.1,#1}%
  \setkeys{cgKeys}{pos={0,0},#1}%
  % -- Function body
  \coordinate (Shift) at (\shift);
  \tdplotsetrotatedcoordsorigin{(Shift)}
  \begin{scope}[tdplot_rotated_coords]
    \draw[fill=white,semithick] (0,0) circle (\@cg@radius);
    \fill[black] (\@cg@radius,0) arc (0:90:\@cg@radius) -- (0,0) --cycle;
    \fill[black] (-\@cg@radius,0) arc (180:270:\@cg@radius) -- (0,0) --cycle;
  \end{scope}
}
\makeatother

%%%%%%%%%%%% Cute clock

\newcommand{\cuteclock}[1][]{
  \begin{scope}[#1]
    \tikzset{
      skinny/.append style={
        inner sep=0,
        outer sep=0
      },
      clockHand/.append style={
        line width=0.2mm
      },
      clockFoot/.append style={
        line width=0.3mm
      }
    }
    
    \tikzmath{
      \R = 3mm;
      \r = 0.3mm;
      \angleHour = 90;
      \angleMinute = -45;
      \lengthHour = 0.5*\R;
      \lengthMinute = 0.9*\R;
      \earSize = 1mm;
      \angleEar = 45;
      \shiftEar = 1.1*\R;
      \lengthFoot = 1mm;
      \angleFoot= 30;
    }
  
    \def\rimColor{black}
    \def\faceColor{white}

    \node[skinny,circle,draw=\rimColor,fill=\faceColor,
    minimum size=2*\R] (cuteclock) at (0,0) {};
  
    \draw[clockHand,rotate=\angleHour] (0,0) to (\lengthHour*1pt,0);
    \draw[clockHand,rotate=\angleMinute] (0,0) to (\lengthMinute*1pt,0);

    \draw[\rimColor,fill=\rimColor] (\r*1pt,0) arc (0:360:\r*1pt);
  
    \foreach \earAngle in {-\angleEar,\angleEar} {
      \draw[\rimColor,fill=\faceColor,rotate=\earAngle,shift={(0,\shiftEar*1pt)}]
      (-\earSize*1pt,0) to (\earSize*1pt,0) arc (0:180:\earSize*1pt) to cycle;
    }
  
    \foreach \footAngle in {-\angleFoot,\angleFoot} {
      \draw[clockFoot,
      rotate=\footAngle,shift={(0,-\R*1pt)}] (0,0) to (0,-\lengthFoot*1pt);
    }
  \end{scope}
}

%%%%%%%%%%%% Arrow as a bullet point

\newcommand{\fancyarrow}{
\resizebox{!}{0.7em}{
\begin{tikzpicture}
  \tikzmath{
    \width=0.7em;
    \height=0.5em;
    \inset=0.2*\width;
  }
  \draw[line width=2mm] (0,0) to (-\inset,\height/2)
  to (-\inset+\width,0) to
  (-\inset,-\height/2) to cycle;
  \path[fill=black] (0,0) to (-\inset,\height/2) to
  (-\inset+\width,0) to cycle;
\end{tikzpicture}
}
}

%%%%%%%%%%%% Tentacle for "mind-map" style connections

\makeatletter
\define@key{tentaclekeys}{start}{\def\xys{#1}}%
\define@key{tentaclekeys}{end}{\def\xye{#1}}%
\define@key{tentaclekeys}{out}{\def\out{#1}}%
\define@key{tentaclekeys}{in}{\def\in{#1}}%
\define@key{tentaclekeys}{widthstart}{\def\ws{#1}}%
\define@key{tentaclekeys}{widthend}{\def\we{#1}}%
\define@key{tentaclekeys}{color}{\def\color{#1}}%
\makeatother
\NewEnviron{tentacle}[1][]{
  % Parameter loading
  \setkeys{tentaclekeys}{start={0,0},#1}
  \setkeys{tentaclekeys}{end={1,-1},#1}
  \setkeys{tentaclekeys}{out=-90,#1}
  \setkeys{tentaclekeys}{in=90,#1}
  \setkeys{tentaclekeys}{widthstart=1mm,#1}
  \setkeys{tentaclekeys}{widthend=0mm,#1}
  \setkeys{tentaclekeys}{color=black,#1}
  % Drawing
  \tikzset{
    tip/.append style={
      color=\color,
      fill=\color,
      line width=0.1mm
    },
    tentacle/.append style={
      color=\color,
      fill=\color,
      line width=0.1mm
    }
  }

  \tikzmath{
    \angss = \out+80;
    \angse = \out+280;
    \anges = \in-100;
    \angee = \in-280;
    \xshfts = cos(\angss)*\ws/2;
    \yshfts = sin(\angss)*\ws/2;
    \xshfte = cos(\anges)*\we/2;
    \yshfte = sin(\anges)*\we/2;
  }
  
  \coordinate (start) at (\xys);
  \coordinate (end) at (\xye);
  \coordinate (start right) at ($(start)+(\xshfts*1pt,\yshfts*1pt)$);
  \coordinate (start left) at ($(start)-(\xshfts*1pt,\yshfts*1pt)$);
  \coordinate (end right) at ($(end)+(\xshfte*1pt,\yshfte*1pt)$);
  \coordinate (end left) at ($(end)-(\xshfte*1pt,\yshfte*1pt)$);
  
  \draw[tip] (start right) arc (\angss:\angse:\ws/2);
  \draw[tip] (end right) arc (\anges:\angee:\we/2);

  \draw[tentacle] (start right) to[out=\out,in=\in] (end right)
  to (end left) to[out=\in,in=\out] (start left);
}

%%%%%%%%%%%% Helper functions for working with lists

\makeatletter

\define@key{@counter@keys}{amount}{\def\@@amount{#1}}
\newcommand{\counter@increment}[2][]{%
  %
  % Increments counter #2 by increment amount.
  %
  % -- Parameters
  \setkeys{@counter@keys}{amount=1,#1}%
  % -- Function body
  \tikzmath{\@@counter@next=int(#2+\@@amount);}%
  \xdef#2{\@@counter@next}%
}

\newcommand{\list@append}[2]{
  %
  % Appends an element to the end of the list.
  %
  % Inputs
  % ------
  % #1 : list
  % #2 : element to append
  % 
  % -- Function body
  \ifthenelse{\equal{#1}{}}{%
    \xdef#1{#2}%
  }{%
    \xdef#1{#1,#2}%
  }%
}

\newcommand{\list@size}[1]{
  %
  % Puts number of list elements into variable \@list@size
  %
  % Inputs
  % ------
  % #1 : list
  %
  % Returns
  % -------
  % \@list@size : list length
  %
  % -- Function body
  \xdef\@list@size{0}%
  \foreach \@list@element in #1 {%
    \counter@increment[amount=1]{\@list@size}%
  }%
}

\newcommand{\list@find}[2]{
  %
  % Find the first matching element and return its index in \@idx.
  %
  % Inputs
  % ------
  % #1 : list
  % #2 : element value to match
  %
  % Returns
  % -------
  % \@idx : index of first matching element (empty if none).
  %
  % -- Function body
  \xdef\@@@counter{0}
  \xdef\@idx{}
  \foreach \@@@element in #1 {
    \counter@increment{\@@@counter}
    \ifthenelse{\equal{\@@@element}{#2}}{
      \xdef\@idx{\@@@counter}
      \breakforeach
    }{}
  }
}

\newcommand{\list@get}[3][]{%
  %
  % Gets element (1-indexed) from a list.
  %
  % Inputs
  % ------
  % #1 (optional): variable to store in (default: \@list@element)
  % #2: list
  % #3: element index (1-indexing)
  %
  % Returns
  % -------
  % \@list@element : #1[#2]
  %
  % -- Function body
  \xdef\@@counter{1}%
  \foreach \@@@element in #2 {%
    \pgfmathparse{\@@counter==#3 ? 1:0}%
    \ifthenelse{\pgfmathresult>0}{%
      \ifthenelse{\equal{#1}{}}{%
        \xdef\@list@element{\@@@element}%
      }{%
        \expandafter\xdef\csname#1\endcsname{\@@@element}%
      }%
      \breakforeach%
    }{}%
    \counter@increment{\@@counter}%
  }%
}
\makeatother

%%%%%%%%%%%% Vector math

\makeatletter

\newcommand{\vector@scale}[2]{
  %
  % Multiply vector #2 by scalar #1, sets list \@vector.
  %
  \list@size{#2}
  \xdef\@scaled{}
  \foreach \@@i in {1,...,\@list@size} {
    \list@get[@a]{#2}{\@@i}
    \tikzmath{\@b=#1*\@a;}
    \list@append{\@scaled}{\@b}
  }
  \xdef\@vector{\@scaled}
}

\newcommand{\vector@add}[2]{
  %
  % Add two vectors, sets list \@vector.
  %
  \list@size{#1}
  \xdef\@sum{}
  \foreach \@@i in {1,...,\@list@size} {
    \list@get[@a]{#1}{\@@i}
    \list@get[@b]{#2}{\@@i}
    \tikzmath{\@c=\@a+\@b;}
    \list@append{\@sum}{\@c}
  }
  \xdef\@vector{\@sum}
}

\newcommand{\matrix@get}[4][]{
  %
  % Get element (#3,#4) from matrix #2. Store result in #1 (default:
  % \@matrix@element).
  %
  \list@get[@@@element]{#2}{#3}
  \list@get[@@@element]{\@@@element}{#4}
  \ifthenelse{\equal{#1}{}}{%
    \xdef\@matrix@element{\@@@element}%
  }{%
    \expandafter\xdef\csname#1\endcsname{\@@@element}%
  }
}

\newcommand{\matrix@mult}[2]{
  %
  % Multiply two matrices #1*#2, sets list \@matrix.
  %
  \list@size{#1}
  \xdef\@@m{\@list@size}
  \list@get[@row]{#1}{1}
  \list@size{\@row}
  \xdef\@@n{\@list@size}
  \xdef\@mult{}
  \foreach \@@i in {1,...,\@@m} {
    \xdef\@new@row{}
    \list@get[@A]{#1}{\@@i}
    \foreach \@@j in {1,...,\@@n} {
      \xdef\@new@el{}
      \foreach \@@k in {1,...,\@@n} {
        \matrix@get[@b]{#2}{\@@k}{\@@j}
        \list@get[@a]{\@A}{\@@k}
        \tikzmath{\@new@el=\@new@el+\@a*\@b;}
        \xdef\@new@el{\@new@el}
      }
      \list@append{\@new@row}{\@new@el}
    }
    \list@append{\@mult}{{\@new@row}}
  }
  \xdef\@matrix{\@mult}
}

\makeatother

%%%%%%%%%%%% Helper grid

\makeatletter
\def\grd@save@target#1{%
  \def\grd@target{#1}}
\def\grd@save@start#1{%
  \def\grd@start{#1}}
\def\grdOpacity{0.5}
\tikzset{
  grid with coordinates/.style={
    to path={%
      \pgfextra{%
        \edef\grd@@target{(\tikztotarget)}%
        \tikz@scan@one@point\grd@save@target\grd@@target\relax
        \edef\grd@@start{(\tikztostart)}%
        \tikz@scan@one@point\grd@save@start\grd@@start\relax
        \draw[minor help lines] (\tikztostart) grid (\tikztotarget);
        \draw[major help lines] (\tikztostart) grid (\tikztotarget);
        \grd@start
        \pgfmathsetmacro{\grd@xa}{\the\pgf@x/1cm}
        \pgfmathsetmacro{\grd@ya}{\the\pgf@y/1cm}
        \grd@target
        \pgfmathsetmacro{\grd@xb}{\the\pgf@x/1cm}
        \pgfmathsetmacro{\grd@yb}{\the\pgf@y/1cm}
        \pgfmathsetmacro{\grd@xc}{\grd@xa + \pgfkeysvalueof{/tikz/grid with coordinates/major step}}
        \pgfmathsetmacro{\grd@yc}{\grd@ya + \pgfkeysvalueof{/tikz/grid with coordinates/major step}}
        \foreach \x in {\grd@xa,\grd@xc,...,\grd@xb}
        \node[anchor=north] at (\x,\grd@ya) {\pgfmathprintnumber{\x}};
        \foreach \y in {\grd@ya,\grd@yc,...,\grd@yb}
        \node[anchor=east] at (\grd@xa,\y) {\pgfmathprintnumber{\y}};
      }
    }
  },
  minor help lines/.style={
    help lines,
    opacity=\grdOpacity,
    step=\pgfkeysvalueof{/tikz/grid with coordinates/minor step}
  },
  major help lines/.style={
    help lines,
    opacity=\grdOpacity,
    line width=\pgfkeysvalueof{/tikz/grid with coordinates/major line width},
    step=\pgfkeysvalueof{/tikz/grid with coordinates/major step}
  },
  grid with coordinates/.cd,
  minor step/.initial=.2,
  major step/.initial=1,
  major line width/.initial=1pt
}

\newcommand{\tiklzhelpgrid}[1][7,4]{%
\def\axmax{#1}
\xdef\axmin{}
\xdef\myGridCounter{1}
\foreach \val in \axmax {
\ifthenelse{\equal{\myGridCounter}{1}}{
\xdef\axmin{-\val}
}{
\xdef\axmin{\axmin,-\val}
}
\xdef\myGridCounter{2}
}
\draw (\axmin) to[grid with coordinates] (\axmax);
}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
