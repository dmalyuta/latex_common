%%%%%%%%%%%% Packages

\usepackage{pgfplots}
\pgfplotsset{compat=newest}

%%%%%%%%%%%% Libraries

\usetikzlibrary{math}
\usetikzlibrary{calc}
\usetikzlibrary{shapes}
\usetikzlibrary{arrows}
\usetikzlibrary{tikzmark}
\usetikzlibrary{positioning}
\usetikzlibrary{scopes}
\usetikzlibrary{shapes.multipart}
\usetikzlibrary{shapes.geometric}
\usetikzlibrary{bending}
\usetikzlibrary{decorations.markings}
\usetikzlibrary{intersections}

% curve through points: (A) to[curve through={(B) .. (C) .. (...)}] {Z};
% \usetikzlibrary{hobby}

%%%%%%%%%%%% Common settings

\newcommand{\tiklzcommonsettings}{
  \tikzset{
    every node/.append style={
      inner sep=0,
      outer sep=0
    },
    axis/.append style={
      black,
      ->
    },
    label text/.append style={
      outer sep=1
    }
  }
}

%%%%%%%%%%%%  Floating point calculations

\ExplSyntaxOn
\cs_set_eq:NN \fpeval \fp_eval:n
\ExplSyntaxOff

%%%%%%%%%%%% Common helper functions

\makeatletter

\define@key{@dimensionalize@keys}{unit}{\def\@@@unit{#1}}
\newcommand{\dimensionalize}[2][]{
  %
  % Append to #1 the unit \@@@unit.
  % Common use case is to append "pt" to a tikzmath output.
  %
  % -- Parameters
  \setkeys{@dimensionalize@keys}{unit=pt,#1}
  % -- Function body
  \xdef#2{#2\@@@unit}
}

\newcommand{\rel@pos}[3][]{
  %
  % Define a position relative to a coordinate.
  %
  % Inputs
  % ------
  % #1 (optional): what to name the new coordinate (default: @rel@pos).
  % #2: relative position
  % #3: origin coordinate
  %
  % -- Function body
  \ifthenelse{\equal{#1}{}}{%
    \xdef\@@coord@name{@rel@pos}%
  }{%
    \xdef\@@coord@name{#1}%
  }%
  \coordinate (\@@coord@name) at ($#2+#3$);%
}

\makeatother

%%%%%%%%%%%% 3D coordinate system settings

\makeatletter
\define@key{coordKeys}{altitude}{\def\altitude{#1}}
\define@key{coordKeys}{azimuth}{\def\azimuth{#1}}
\makeatother
\newcommand{\tiklzSetViewAngle}[1][]{
  \setkeys{coordKeys}{altitude=20,#1}%
  \setkeys{coordKeys}{azimuth=40,#1}%
  \tikzmath{
    \tikzAltitude=90-\altitude;
    \tikzAzimuth=90+\azimuth;
  }
  \tdplotsetmaincoords{\tikzAltitude}{\tikzAzimuth}
  \tikzmath{
    \X = cos(\altitude)*cos(\azimuth);
    \Y = cos(\altitude)*sin(\azimuth);
    \Z = sin(\altitude);
  }
  \xdef\viewVector{\X,\Y,\Z}
}

%%%%%%%%%%%% "Loop" block (used in ARC 2020 survey paper with Yue Yu)

\makeatletter
\define@key{loopKeys}{position}{\def\position{#1}}%
\define@key{loopKeys}{title}{\def\title{#1}}%
\define@key{loopKeys}{text}{\def\text{#1}}%
\define@key{loopKeys}{height}{\def\height{#1}}%
\define@key{loopKeys}{width}{\def\width{#1}}%
\define@key{loopKeys}{textalign}{\def\textalign{#1}}%
\define@key{loopKeys}{bgcolor}{\def\bgcolor{#1}}%
\define@key{loopKeys}{arrowcolor}{\def\arrowcolor{#1}}%
\newcommand{\loopblock}[1][]{
  % Parameters
  \setkeys{loopKeys}{position=,#1}%
  \setkeys{loopKeys}{title=,#1}%
  \setkeys{loopKeys}{text=,#1}%
  \setkeys{loopKeys}{height=20mm,#1}%
  \setkeys{loopKeys}{width=40mm,#1}%
  \setkeys{loopKeys}{textalign=middle,#1}% middle,top
  \setkeys{loopKeys}{bgcolor=black!30,#1}% middle,top
  \setkeys{loopKeys}{arrowcolor=black,#1}% middle,top
  %
  % Draw
  % -- Dimensions
  \def\@loop@sw@sep{3mm}
  \def\@loop@corner@radius{3mm}
  \def\@loop@linewidth{1mm}
  \def\@loop@arrow@left@pad{1mm}
  \def\@loop@title@pad{1mm}
  \def\@loop@area@text@pad{2mm}
  % -- Styles
  \tiklzcommonsettings
  \tikzset{
    loop arrow/.append style={
      -latex,
      line width=0.6mm,
      line cap=round
    },
    loop bg/.append style={
      line cap=round
    },
    loop title/.append style={
      align=left,
      anchor=west,
      font={\bfseries\small},
      outer sep=\@loop@title@pad
    },
    loop area text/.append style={
      rectangle,
      minimum width=\width-2*\@loop@corner@radius,
      text width=\width-2*\@loop@corner@radius,
      % draw=black,
      align=left,
      font={\footnotesize}
    }
  }
  \begin{scope}[shift={\position}]
    % -- Title
    \node[loop title] (loop title) at (0,0) {\title};
    % Measure title height and width
    \path let
    \p1=(loop title.east),
    \p2=(loop title.south east),
    \p3=(loop title.west)
    in \pgfextra{
      \tikzmath{\@loop@title@height = \y1-\y2;}
      \tikzmath{\@loop@title@width = \x1-\x3;}
      \dimensionalize{\@loop@title@height}
      \dimensionalize{\@loop@title@width}
    };
    % Starting point for arrow
    \coordinate (loop arrow start) at
    ($(loop title.south west)+(\@loop@arrow@left@pad+\@loop@title@pad,0)$);
    % -- Loop area background
    \path[
    loop bg,
    fill=\bgcolor
    ] (loop arrow start) -- node[pos=0.5](loop@area@middle@vertical){}
    ++(0,-\height+\@loop@title@height+\@loop@corner@radius)
    arc (180:270:\@loop@corner@radius)
    -- node[pos=0.5](loop@area@middle@horizontal){}
    ++(\width-\@loop@corner@radius*2,0)
    arc (-90:0:\@loop@corner@radius)
    -- ++(0,{\height-2*\@loop@corner@radius})
    arc (0:90:\@loop@corner@radius)
    -- (loop title.east)
    -- (loop title.south east)
    --cycle;
    % -- Loop area perimeter arrow
    \draw[
    loop arrow,
    draw=\arrowcolor
    ] (loop arrow start) --
    ++(0,-\height+\@loop@title@height+\@loop@corner@radius)
    arc (180:270:\@loop@corner@radius)
    -- ++(\width-\@loop@corner@radius*2,0)
    arc (-90:0:\@loop@corner@radius)
    -- ++(0,{\height-2*\@loop@corner@radius})
    arc (0:90:\@loop@corner@radius)
    -- (loop title.east);
    % -- Loop area text
    \path let
    \p1=(loop@area@middle@vertical),
    \p2=(loop@area@middle@horizontal),
    \p3=(loop title.south)
    in \pgfextra{
      \ifthenelse{\equal{\textalign}{middle}}{
        \coordinate (loop_area_middle) at (\x2,\y1-\@loop@corner@radius/2);
        \node[loop area text] at (loop_area_middle) {\text};
      }{
        \coordinate (loop_area_top) at (\x2,\y3-\@loop@area@text@pad);
        \node[loop area text,anchor=north] at (loop_area_top) {\text};
      } 
    };
  \end{scope}
}
\makeatother

%%%%%%%%%%%% Selector Simulink-like block

\newcommand{\selector}[1]{
  % #1 : list of input i/output j connections, e.g. 1/1,2/,3/2 for 3-input
  %      2-output selector with mapping 1->1,3->2.
  \def\connections{#1}
  \xdef\Nu{0}
  \xdef\No{0}
  \foreach \i/\j in \connections {
    \tikzmath{\Nu=int(\Nu+1);}
    \ifthenelse{\equal{\j}{}}{}{
      \tikzmath{\No=int(\No+1);}
    }
    \xdef\Nu{\Nu}
    \xdef\No{\No}
  }
  
  \tikzmath{
    \elsz = 2;
    \elsep = 4;
    \blkh = (\Nu+0.5)*\elsep;
    \blkw = 8*\elsz;
  }

  \tikzset{
    every node/.append style={
      inner sep=0,
      outer sep=0
    },
    element/.append style={
      draw=black,
      rectangle,
      minimum size=\elsz pt
    },
    block/.append style={
      rectangle,
      draw=black,
      fill=white,
      minimum width=\blkw pt,
      minimum height=\blkh pt
    }
  }

  \node[block] (selector) at (0,0) {};

  \path let \p1=(selector.center) in \pgfextra{
    \xdef\k{0}
    \foreach \i/\j/\name in \connections {
      \tikzmath{
        \elux = \x1-\blkw/2+\elsz*3/2;
        \eluy = \y1+\elsep*(\Nu-1)/2-(\i-1)*\elsep;
      }
      \ifthenelse{\equal{\j}{}}{
        \node[element=white] at (\elux pt,\eluy pt) {};
      }{
        \tikzmath{
          \k = int(\k+1);
          \elox = \x1+\blkw/2-\elsz*3/2;
          \eloy = \y1+\elsep*(\No-1)/2-(\k-1)*\elsep;
        }
        \node[element,fill=black] (input) at (\elux pt,\eluy pt) {};
        \node[element,fill=black] (output) at (\elox pt,\eloy pt) {};
        \ifthenelse{\equal{\name}{}}{
          \draw (input.east) -- (output.west);
        }{
          \draw (input.east) --
          node[pos=0.5,circle,fill=white,scale=0.4,inner sep=0.5mm]{\name}
          (output.west);
        }
        
        \xdef\k{\k}
      }
    }
  };
}

%%%%%%%%%%%% Multicolor line (dashed)

\newcommand{\multicolorline}[5]{
  % #1: origin
  % #2: destination
  % #3: (origin) <INSERT #3> (destination)
  % #4: colors list
  % #5: line style
  \xdef\dashunit{pt}
  \xdef\dashlength{3}
  \xdef\dashstep{-\dashlength}
  \xdef\colorcount{0}
  \foreach \color in {#4} {
    \tikzmath{
      \dashstep=\dashstep+\dashlength;
      \colorcount=int(\colorcount+1);
    }
    \xdef\dashstep{\dashstep}
    \xdef\colorcount{\colorcount}
  }
  \path[draw=none] (#1) #3 node[pos=1](multicolorlinedestination){} (#2);
  \node[outer sep=1mm] (multicolorlinedestination) at (multicolorlinedestination) {};
  \foreach \color [count=\i] in {#4} {
    \pgfmathparse{\i==\colorcount ? 1:0}
    \ifthenelse{\pgfmathresult>0}{
      \xdef\colorlast{\color}
    }{
      \tikzmath{\dashphase=int(\dashlength*(\i-1));}
      \draw[#5,
      -,
      draw=\color,
      dash pattern=on \dashlength\dashunit off \dashstep\dashunit,
      dash phase=\dashphase\dashunit] (#1) #3 (multicolorlinedestination);
    }
  }
  \draw[#5,
  draw=\colorlast,
  dash pattern=on \dashlength\dashunit off \dashstep\dashunit,
  dash phase=\dashstep\dashunit] (#1) #3 (#2);
}

%%%%%%%%%%%% Ellipsoid

\makeatletter
\define@key{ellipseKeys}{x}{\def\x{#1}}
\define@key{ellipseKeys}{y}{\def\y{#1}}
\define@key{ellipseKeys}{maj}{\def\maj{#1}}
\define@key{ellipseKeys}{min}{\def\min{#1}}
\define@key{ellipseKeys}{rot}{\def\rot{#1}}
\define@key{ellipseKeys}{style}{\def\style{#1}}
\define@key{ellipseKeys}{name}{\def\name{#1}}
\makeatother
\newcommand{\ellipse}[1][]{
  \setkeys{ellipseKeys}{x=0,#1}%
  \setkeys{ellipseKeys}{y=0,#1}%
  \setkeys{ellipseKeys}{min=1,#1}%
  \setkeys{ellipseKeys}{maj=2,#1}%
  \setkeys{ellipseKeys}{rot=0,#1}%
  \setkeys{ellipseKeys}{style={},#1}%
  \setkeys{ellipseKeys}{name=ellipse,#1}%
  \node[
  \style,
  inner sep=0,
  outer sep=0,
  ellipse,
  minimum width=\min*1cm,
  minimum height=\maj*1cm,
  rotate=\rot] (\name) at (\x,\y) {};
}

%%%%%%%%%%%% Quadrotor

\newcommand{\sphereCoord}[2]{
  % return x,y,z a point on a sphere
  % #1: sphere radius
  % #2: azimuth angle, altitude angle
  \tikzmath{
    \X = #1*cos({#2}[1])*cos({#2}[0]);
    \Y = #1*cos({#2}[1])*sin({#2}[0]);
    \Z = #1*sin({#2}[1]);
  }
}

\newcommand{\convertTaitBryanToTikZ}[3]{
  % set (\TikZalpha,\TikZbeta,\TikZgamma) the coordinates to
  % tdplotsetrotatedcoords
  \pgfmathsetmacro\yaw{#1}
  \pgfmathsetmacro\pitch{#2}
  \pgfmathsetmacro\roll{#3}
  \tikzmath{
    \degToRad = \fpeval{pi/180};
    \radToDeg = \fpeval{180/pi};
    \TBpsi = \yaw*\degToRad;
    \TBtheta = \pitch*\degToRad;
    \TBphi = \roll*\degToRad;
    % 
    \TikZbeta = \fpeval{acos(cos(\TBtheta)*cos(\TBphi))};
    \TikZalpha = 0;
    \TikZgamma = 0;
  }
  \pgfmathparse{abs(\TikZbeta)<1e-4 ? 1:0}
  \ifthenelse{\pgfmathresult>0}{
    % Gimbal lock
    \tikzmath{
      \TikZgamma = 0;
      \TikZalpha = \fpeval{\TBpsi};
    }
  }{
    % Normal operation
    \tikzmath{
      \TikZgamma =
      atan2(\fpeval{cos(\TBtheta)*sin(\TBphi)},\fpeval{sin(\TBtheta)})*
      \degToRad;
      \TikZalpha = atan2(
      \fpeval{cos(\TBphi)*sin(\TBpsi)*sin(\TBtheta)-cos(\TBpsi)*sin(\TBphi)},
      \fpeval{sin(\TBpsi)*sin(\TBphi)+cos(\TBpsi)*cos(\TBphi)*sin(\TBtheta)})*\degToRad;
    }
  }
  \tikzmath{
    \TikZalpha = \TikZalpha*\radToDeg;
    \TikZbeta = \TikZbeta*\radToDeg;
    \TikZgamma = \TikZgamma*\radToDeg;
  }
  \xdef\TikZalpha{\TikZalpha}
  \xdef\TikZbeta{\TikZbeta}
  \xdef\TikZgamma{\TikZgamma}
}

\makeatletter
\define@key{droneKeysNew}{yaw}{\def\yaw{#1}}
\define@key{droneKeysNew}{pitch}{\def\pitch{#1}}
\define@key{droneKeysNew}{roll}{\def\roll{#1}}
\define@key{droneKeysNew}{x}{\def\x{#1}}
\define@key{droneKeysNew}{y}{\def\y{#1}}
\define@key{droneKeysNew}{scale}{\def\scale{#1}}
\define@key{droneKeysNew}{layers}{\def\layers{#1}}
\define@key{droneKeysNew}{showaxes}{\def\showaxes{#1}}
\makeatother
\xdef\QuadCounter{1}
\newcommand{\quadrotor}[1][]{
  \setkeys{droneKeysNew}{yaw=0,#1}%
  \setkeys{droneKeysNew}{pitch=0,#1}%
  \setkeys{droneKeysNew}{roll=0,#1}%
  \setkeys{droneKeysNew}{x=0,#1}%
  \setkeys{droneKeysNew}{y=0,#1}%
  \setkeys{droneKeysNew}{scale=1,#1}%
  \setkeys{droneKeysNew}{showaxes=false,#1}%
  \setkeys{droneKeysNew}{layers={AFR,ARR,ARL,BH,AFL,RFR,RFL,RRR,RRL},#1}%
  % Parameters
  \tikzmath{
    \Larm = 1;
    \Rr = 0.9;
    \armNorm = sqrt(2)*\Larm;
    \rx1 = \Larm;
    \ry1 = \Larm;
    \rx2 = \Larm;
    \ry2 = -\Larm;
    \rx3 = -\Larm;
    \ry3 = -\Larm;
    \rx4 = -\Larm;
    \ry4 = \Larm;
    \armwidth=0.40mm*\scale;
    \rotorlinewidth=0.40mm*\scale;
    \hubsize=\scale*0.15mm;
  }
  \def\frontRotorInnerColor{orange!100}
  \def\frontRotorOuterColor{orange!40}
  \def\frontRearInnerColor{black!40}
  \def\frontRearOuterColor{black!5}
  \tikzset{
    rotor/.append style={
      shading=radial,
      line width=\rotorlinewidth,
      fill opacity=0.8
    }
  }
  \convertTaitBryanToTikZ{\yaw}{\pitch}{\roll}
  % Plot quad
  \tdplotsetrotatedcoords{\TikZalpha}{\TikZbeta}{\TikZgamma}
  \begin{scope}[
    shift={(\x,\y)},
    tdplot_rotated_coords,
    scale=\scale]
    % Axes
    \ifthenelse{\equal{\showaxes}{}}{
      \draw[->,red] (0,0,0) -- (1,0,0);
      \draw[->,green] (0,0,0) -- (0,1,0);
      \draw[->,blue] (0,0,0) -- (0,0,1);
    }{}
    % Arms
    \expandafter\newsavebox\csname AFR\QuadCounter\endcsname
    \expandafter\newsavebox\csname AFL\QuadCounter\endcsname
    \expandafter\newsavebox\csname ARR\QuadCounter\endcsname
    \expandafter\newsavebox\csname ARL\QuadCounter\endcsname
    \foreach \i/\name in {1/FL,2/FR,3/RR,4/RL} {
      \begin{lrbox}{\csname A\name\QuadCounter\endcsname}
        \tikzmath{
          \armX = \rx\i/(\armNorm)*\hubsize;
          \armY = \ry\i/(\armNorm)*\hubsize;
        }
        \draw[line width=\armwidth]
        (\armX,\armY,0) to (\rx\i,\ry\i,0);
      \end{lrbox}
      \global%
      \expandafter\setbox\csname A\name\QuadCounter\endcsname%
      \expandafter\box\csname A\name\QuadCounter\endcsname%
    }
    % Electronics hub
    \expandafter\newsavebox\csname BH\QuadCounter\endcsname
    \begin{lrbox}{\csname BH\QuadCounter\endcsname}
      \node[
      circle,
      shading=radial,
      outer color=black!100,
      inner color=black!10,
      minimum size=\hubsize*1cm,
      inner sep=0
      ] at (0,0,0) {};
    \end{lrbox}
    % Rotors
    \expandafter\newsavebox\csname RFR\QuadCounter\endcsname
    \expandafter\newsavebox\csname RFL\QuadCounter\endcsname
    \expandafter\newsavebox\csname RRR\QuadCounter\endcsname
    \expandafter\newsavebox\csname RRL\QuadCounter\endcsname
    % Rotor 1
    \begin{lrbox}{\csname RFL\QuadCounter\endcsname}
      \begin{scope}[shift={(\rx1,\ry1)}]
        \draw[
        rotor,
        outer color=\frontRotorOuterColor,
        inner color=\frontRotorInnerColor]
        (0,0) circle (\Rr);
      \end{scope}
    \end{lrbox}
    % Rotor 2
    \begin{lrbox}{\csname RFR\QuadCounter\endcsname}
      \begin{scope}[shift={(\rx2,\ry2)}]
        \draw[
        rotor,
        outer color=\frontRotorOuterColor,
        inner color=\frontRotorInnerColor]
        (0,0) circle (\Rr);
      \end{scope}
    \end{lrbox}            
    % Rotor 3
    \begin{lrbox}{\csname RRR\QuadCounter\endcsname}
      \begin{scope}[shift={(\rx3,\ry3)}]
        \draw[
        rotor,
        outer color=\frontRearOuterColor,
        inner color=\frontRearInnerColor]
        (0,0) circle (\Rr);
      \end{scope}
    \end{lrbox}                        
    % Rotor 4
    \begin{lrbox}{\csname RRL\QuadCounter\endcsname}
      \begin{scope}[shift={(\rx4,\ry4)}]
        \draw[
        rotor,
        outer color=\frontRearOuterColor,
        inner color=\frontRearInnerColor]
        (0,0) circle (\Rr);
      \end{scope}
    \end{lrbox}
    % Now draw everything
    \foreach \obj in \layers {
      \expandafter\usebox\csname \obj\QuadCounter\endcsname
    }
  \end{scope}
  \tikzmath{\QuadCounter=int(\QuadCounter+1);}
  \xdef\QuadCounter{\QuadCounter}
}

%%%%%%%%%%%% Vector difference

\newcommand{\vectorDiff}[2]{
  % return the difference a - b
  % #1: vector a
  % #2: vector b
  \tikzmath{
    \X = {#1}[0]-{#2}[0];
    \Y = {#1}[1]-{#2}[1];
    \Z = {#1}[2]-{#2}[2];
  }
}

%%%%%%%%%%%% Vector dot product

\newcommand{\dotProduct}[2]{
  % return the dot product a . b
  % #1: vector a
  % #2: vector b
  \tikzmath
  {
    \OUT = {#1}[0]*{#2}[0]+{#1}[1]*{#2}[1]+{#1}[2]*{#2}[2];
  }
}

%%%%%%%%%%%% Vector cross product

\newcommand{\crossProduct}[2]{
  % return the cross product a x b
  % #1: vector a
  % #2: vector b
  \tikzmath
  {
    \X = {#1}[1]*{#2}[2]-{#1}[2]*{#2}[1];
    \Y = {#1}[2]*{#2}[0]-{#1}[0]*{#2}[2];
    \Z = {#1}[0]*{#2}[1]-{#1}[1]*{#2}[0];
  }
}

%%%%%%%%%%%% Rocket lander

\makeatletter
\define@key{rocketKeys}{shift}{\def\shift{#1}}
\define@key{rocketKeys}{legs}{\def\legs{#1}}
\define@key{rocketKeys}{fire}{\def\fire{#1}}
\makeatother
\newcommand{\rocket}[1][]{
  \setkeys{rocketKeys}{shift={(0,0)},#1}%
  \setkeys{rocketKeys}{legs=out,#1}%
  \setkeys{rocketKeys}{fire=false,#1}%
  \begin{scope}[shift={\shift}]
    \ifthenelse{\equal{\legs}{out}}{
      \tikzmath{\lAng = 60;}
    }{
      \tikzmath{\lAng = 180;}
    }
    \tikzmath{
      % User
      \rL = 2;
      \rW = 0.3;
      \lL = 0.6;
      \lW = 0.1;
      \lCF = 0.2;
      \lCH = 0.15;
      \eW = 0.3*\rW;
      \eH = 0.07;
      \eAng = 30;
      \eBellOutAng = -30;
      \eBellInAng = 90;
      \fH = 0.4;
      % Derived
      \lX = \lL*sin(\lAng);
      \lH = \lL*cos(\lAng);
      \eX = \eH*tan(\eAng);
    }
    \tikzset{
      every node/.append style={
        inner sep=0,
        outer sep=0
      },
      fuselage/.append style={
        rectangle,
        draw=black,
        minimum width=\rW cm,
        minimum height=\rL cm,
        shading=axis,
        shading angle=0,
        left color=white,
        right color=gray
      },
      leg/.append style={
        fill=black,
        draw=black,
        line join=bevel
      },
      leg cylinder/.append style={
        black,
        line width=0.2mm
      },
      engine bell/.append style={
        draw=black,
        shading=axis,
        shading angle=0,
        left color=gray,
        right color=black
      },
      engine fire/.append style={
        shading=axis,
        top color=orange,
        bottom color=yellow,
        draw=none
      }
    }
    \node[fuselage] (body) at (0,0) {};

    \draw[leg] (body.south west) to ++(-\lX,-\lH) to
    node[pos=\lCF](cylinder left){} ++(\lX,\lH+\lW) -- cycle;
    \draw[leg] (body.south east) to ++(\lX,-\lH) to
    node[pos=\lCF](cylinder right){} ++(-\lX,\lH+\lW) -- cycle;

    \draw[leg cylinder] ($(body.south west)+(0,\lW+\lCH)$)
    to (cylinder left);
    \draw[leg cylinder] ($(body.south east)+(0,\lW+\lCH)$)
    to (cylinder right);

    \coordinate (engine south east) at ($(body.south)+(\eW/2+\eX,-\eH)$);
    \coordinate (engine south west) at ($(body.south)+(-\eW/2-\eX,-\eH)$);
    
    \ifthenelse{\equal{\fire}{true}}{
      \draw[engine fire] (engine south east) to ++(-\eW/2-\eX,-\fH) to
      (engine south west) --cycle;
    }{}

    \draw[engine bell] (body.south) to ++(\eW/2,0)
    to[out=\eBellOutAng,in=\eBellInAng] ++(\eX,-\eH)
    to ++(-\eW-2*\eX,0)
    to[out=\eBellInAng,in=-180-\eBellOutAng] ++(\eX,\eH)
    --cycle;
  \end{scope}
}

%%%%%%%%%%%% Center of gravity

\makeatletter
\define@key{cgKeys}{shift}{\def\shift{#1}}
\makeatother
\newcommand{\cg}[1][]{
  \setkeys{cgKeys}{shift={(0,0)},#1}%
  \begin{scope}[shift={\shift}]
    % CG
    \tikzmath{
      \cgR = 0.15;
    }
    \tikzset{
      cg bg/.append style={
        circle,
        fill=white,
        draw=black,
        minimum size=\cgR cm
      },
      cg fg/.append style={
        circle,
        fill=black,
        draw=black
      }
    }
    \node[cg bg] at (0,0) {};
    \draw[cg fg] ($(0,0)+(0:\cgR cm/2)$) arc (0:90:\cgR cm/2) to (0,0) --
    cycle;
    \draw[cg fg] ($(0,0)+(180:\cgR cm/2)$) arc (180:270:\cgR cm/2) to (0,0) -- cycle;
  \end{scope}
}

%%%%%%%%%%%% Cute clock

\newcommand{\cuteclock}[1][]{
  \begin{scope}[#1]
    \tikzset{
      skinny/.append style={
        inner sep=0,
        outer sep=0
      },
      clockHand/.append style={
        line width=0.2mm
      },
      clockFoot/.append style={
        line width=0.3mm
      }
    }
    
    \tikzmath{
      \R = 3mm;
      \r = 0.3mm;
      \angleHour = 90;
      \angleMinute = -45;
      \lengthHour = 0.5*\R;
      \lengthMinute = 0.9*\R;
      \earSize = 1mm;
      \angleEar = 45;
      \shiftEar = 1.1*\R;
      \lengthFoot = 1mm;
      \angleFoot= 30;
    }
  
    \def\rimColor{black}
    \def\faceColor{white}

    \node[skinny,circle,draw=\rimColor,fill=\faceColor,
    minimum size=2*\R] (cuteclock) at (0,0) {};
  
    \draw[clockHand,rotate=\angleHour] (0,0) to (\lengthHour*1pt,0);
    \draw[clockHand,rotate=\angleMinute] (0,0) to (\lengthMinute*1pt,0);

    \draw[\rimColor,fill=\rimColor] (\r*1pt,0) arc (0:360:\r*1pt);
  
    \foreach \earAngle in {-\angleEar,\angleEar} {
      \draw[\rimColor,fill=\faceColor,rotate=\earAngle,shift={(0,\shiftEar*1pt)}]
      (-\earSize*1pt,0) to (\earSize*1pt,0) arc (0:180:\earSize*1pt) to cycle;
    }
  
    \foreach \footAngle in {-\angleFoot,\angleFoot} {
      \draw[clockFoot,
      rotate=\footAngle,shift={(0,-\R*1pt)}] (0,0) to (0,-\lengthFoot*1pt);
    }
  \end{scope}
}

%%%%%%%%%%%% Arrow as a bullet point

\newcommand{\fancyarrow}{
\resizebox{!}{0.7em}{
\begin{tikzpicture}
  \tikzmath{
    \width=0.7em;
    \height=0.5em;
    \inset=0.2*\width;
  }
  \draw[line width=2mm] (0,0) to (-\inset,\height/2)
  to (-\inset+\width,0) to
  (-\inset,-\height/2) to cycle;
  \path[fill=black] (0,0) to (-\inset,\height/2) to
  (-\inset+\width,0) to cycle;
\end{tikzpicture}
}
}

%%%%%%%%%%%% Tentacle for "mind-map" style connections

\makeatletter
\define@key{tentaclekeys}{start}{\def\xys{#1}}%
\define@key{tentaclekeys}{end}{\def\xye{#1}}%
\define@key{tentaclekeys}{out}{\def\out{#1}}%
\define@key{tentaclekeys}{in}{\def\in{#1}}%
\define@key{tentaclekeys}{widthstart}{\def\ws{#1}}%
\define@key{tentaclekeys}{widthend}{\def\we{#1}}%
\define@key{tentaclekeys}{color}{\def\color{#1}}%
\makeatother
\NewEnviron{tentacle}[1][]{
  % Parameter loading
  \setkeys{tentaclekeys}{start={0,0},#1}
  \setkeys{tentaclekeys}{end={1,-1},#1}
  \setkeys{tentaclekeys}{out=-90,#1}
  \setkeys{tentaclekeys}{in=90,#1}
  \setkeys{tentaclekeys}{widthstart=1mm,#1}
  \setkeys{tentaclekeys}{widthend=0mm,#1}
  \setkeys{tentaclekeys}{color=black,#1}
  % Drawing
  \tikzset{
    tip/.append style={
      color=\color,
      fill=\color,
      line width=0.1mm
    },
    tentacle/.append style={
      color=\color,
      fill=\color,
      line width=0.1mm
    }
  }

  \tikzmath{
    \angss = \out+80;
    \angse = \out+280;
    \anges = \in-100;
    \angee = \in-280;
    \xshfts = cos(\angss)*\ws/2;
    \yshfts = sin(\angss)*\ws/2;
    \xshfte = cos(\anges)*\we/2;
    \yshfte = sin(\anges)*\we/2;
  }
  
  \coordinate (start) at (\xys);
  \coordinate (end) at (\xye);
  \coordinate (start right) at ($(start)+(\xshfts*1pt,\yshfts*1pt)$);
  \coordinate (start left) at ($(start)-(\xshfts*1pt,\yshfts*1pt)$);
  \coordinate (end right) at ($(end)+(\xshfte*1pt,\yshfte*1pt)$);
  \coordinate (end left) at ($(end)-(\xshfte*1pt,\yshfte*1pt)$);
  
  \draw[tip] (start right) arc (\angss:\angse:\ws/2);
  \draw[tip] (end right) arc (\anges:\angee:\we/2);

  \draw[tentacle] (start right) to[out=\out,in=\in] (end right)
  to (end left) to[out=\in,in=\out] (start left);
}

%%%%%%%%%%%% Helper functions for working with lists

\makeatletter

\define@key{@counter@keys}{amount}{\def\@@amount{#1}}
\newcommand{\counter@increment}[2][]{%
  %
  % Increments counter #2 by increment amount.
  %
  % -- Parameters
  \setkeys{@counter@keys}{amount=1,#1}%
  % -- Function body
  \tikzmath{\@@counter@next=int(#2+\@@amount);}%
  \xdef#2{\@@counter@next}%
}

\newcommand{\list@append}[2]{
  %
  % Appends an element to the end of the list.
  %
  % Inputs
  % ------
  % #1 : list
  % #2 : element to append
  % 
  % -- Function body
  \ifthenelse{\equal{#1}{}}{%
    \xdef#1{#2}%
  }{%
    \xdef#1{#1,#2}%
  }%
}

\newcommand{\list@size}[1]{
  %
  % Puts number of list elements into variable \@list@size
  %
  % Inputs
  % ------
  % #1 : list
  %
  % Returns
  % -------
  % \@list@size : list length
  %
  % -- Function body
  \xdef\@list@size{0}%
  \foreach \@list@element in #1 {%
    \counter@increment[amount=1]{\@list@size}%
  }%
}

\newcommand{\list@find}[2]{
  %
  % Find the first matching element and return its index in \@idx.
  %
  % Inputs
  % ------
  % #1 : list
  % #2 : element value to match
  %
  % Returns
  % -------
  % \@idx : index of first matching element (empty if none).
  %
  % -- Function body
  \xdef\@@@counter{0}
  \xdef\@idx{}
  \foreach \@@@element in #1 {
    \counter@increment{\@@@counter}
    \ifthenelse{\equal{\@@@element}{#2}}{
      \xdef\@idx{\@@@counter}
      \breakforeach
    }{}
  }
}

\newcommand{\list@get}[3][]{%
  %
  % Gets element (1-indexed) from a list.
  %
  % Inputs
  % ------
  % #1 (optional): variable to store in (default: \@list@element)
  % #2: list
  % #3: element index (1-indexing)
  %
  % Returns
  % -------
  % \@list@element : #1[#2]
  %
  % -- Function body
  \xdef\@@counter{1}%
  \foreach \@@@element in #2 {%
    \pgfmathparse{\@@counter==#3 ? 1:0}%
    \ifthenelse{\pgfmathresult>0}{%
      \ifthenelse{\equal{#1}{}}{%
        \xdef\@list@element{\@@@element}%
      }{%
        \expandafter\xdef\csname#1\endcsname{\@@@element}%
      }%
      \breakforeach%
    }{}%
    \counter@increment{\@@counter}%
  }%
}
\makeatother

%%%%%%%%%%%% Helper grid

\makeatletter
\def\grd@save@target#1{%
  \def\grd@target{#1}}
\def\grd@save@start#1{%
  \def\grd@start{#1}}
\def\grdOpacity{0.5}
\tikzset{
  grid with coordinates/.style={
    to path={%
      \pgfextra{%
        \edef\grd@@target{(\tikztotarget)}%
        \tikz@scan@one@point\grd@save@target\grd@@target\relax
        \edef\grd@@start{(\tikztostart)}%
        \tikz@scan@one@point\grd@save@start\grd@@start\relax
        \draw[minor help lines] (\tikztostart) grid (\tikztotarget);
        \draw[major help lines] (\tikztostart) grid (\tikztotarget);
        \grd@start
        \pgfmathsetmacro{\grd@xa}{\the\pgf@x/1cm}
        \pgfmathsetmacro{\grd@ya}{\the\pgf@y/1cm}
        \grd@target
        \pgfmathsetmacro{\grd@xb}{\the\pgf@x/1cm}
        \pgfmathsetmacro{\grd@yb}{\the\pgf@y/1cm}
        \pgfmathsetmacro{\grd@xc}{\grd@xa + \pgfkeysvalueof{/tikz/grid with coordinates/major step}}
        \pgfmathsetmacro{\grd@yc}{\grd@ya + \pgfkeysvalueof{/tikz/grid with coordinates/major step}}
        \foreach \x in {\grd@xa,\grd@xc,...,\grd@xb}
        \node[anchor=north] at (\x,\grd@ya) {\pgfmathprintnumber{\x}};
        \foreach \y in {\grd@ya,\grd@yc,...,\grd@yb}
        \node[anchor=east] at (\grd@xa,\y) {\pgfmathprintnumber{\y}};
      }
    }
  },
  minor help lines/.style={
    help lines,
    opacity=\grdOpacity,
    step=\pgfkeysvalueof{/tikz/grid with coordinates/minor step}
  },
  major help lines/.style={
    help lines,
    opacity=\grdOpacity,
    line width=\pgfkeysvalueof{/tikz/grid with coordinates/major line width},
    step=\pgfkeysvalueof{/tikz/grid with coordinates/major step}
  },
  grid with coordinates/.cd,
  minor step/.initial=.2,
  major step/.initial=1,
  major line width/.initial=1pt
}

\newcommand{\tiklzhelpgrid}[1][7,4]{%
\def\axmax{#1}
\xdef\axmin{}
\xdef\myGridCounter{1}
\foreach \val in \axmax {
\ifthenelse{\equal{\myGridCounter}{1}}{
\xdef\axmin{-\val}
}{
\xdef\axmin{\axmin,-\val}
}
\xdef\myGridCounter{2}
}
\draw (\axmin) to[grid with coordinates] (\axmax);
}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
